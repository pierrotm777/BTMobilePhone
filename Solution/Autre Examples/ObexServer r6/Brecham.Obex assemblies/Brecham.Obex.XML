<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Brecham.Obex</name>
    </assembly>
    <members>
        <member name="F:Brecham.Obex.DigestChallengeHeaderId.Nonce">
            <summary>
            0x00	Nonce	16	String of bytes representing the nonce.
            </summary>
        </member>
        <member name="F:Brecham.Obex.DigestChallengeHeaderId.Options">
            <summary>
            0x01	Options	1	Optional Challenge Information	0
            </summary>
        </member>
        <member name="F:Brecham.Obex.DigestChallengeHeaderId.Realm">
            <summary>
            0x02	Realm	n	A displayable string indicating which userid and/or password to use.
            </summary>
            <remarks>
            &#x2026;
            The first byte of the string is the character set to use. The character 
            set uses the same values as those defined in IrLMP for the nickname
            </remarks>
        </member>
        <member name="T:Brecham.Obex.DigestChallengeOptions">
            <summary>
            Option flags for use in the Authentication Challenge header.
            </summary>
            -
            <remarks>&#x201C;
            The option field is optional. If an option field is not sent the assumed 
            value for it is 0. Two options are defined. The first controls the sending 
            of a userid. If this option is set then the entity receiving the challenge 
            must respond with a userid in the digest response string. The second option 
            indicates the access mode being offered by the sender of the challenge. The 
            two access modes are full access (both read and write) and read only.
            &#x201D;
            </remarks>
        </member>
        <member name="F:Brecham.Obex.DigestChallengeOptions.None">
            <summary>
            No options are set.
            </summary>
        </member>
        <member name="F:Brecham.Obex.DigestChallengeOptions.IncludeUserIdInResponse">
            <summary>
            &#x201C;When set, the User Id must be sent in the authenticate response.&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.DigestChallengeOptions.AccessModeReadOnly">
            <summary>
            &#x201C;Access mode: Read Only when set, otherwise Full access is permitted.&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.DigestResponseHeaderId.RequestDigest">
            <summary>
            0x00	Request-digest	16	String of bytes representing the request digest.
            </summary>
        </member>
        <member name="F:Brecham.Obex.DigestResponseHeaderId.UserId">
            <summary>
            0x01	User Id	N	User ID string of length n. Max size is 20 bytes.
            </summary>
        </member>
        <member name="F:Brecham.Obex.DigestResponseHeaderId.Nonce">
            <summary>
            0x02	Nonce	16	The nonce sent in the digest challenge string.
            </summary>
        </member>
        <member name="T:Brecham.Obex.Authentication">
            <summary>
            Some methods so create and parse the OBEX Authentication header value.
            </summary>
        </member>
        <member name="M:Brecham.Obex.Authentication.CreateDigestChallengeHeader(System.Byte[],Brecham.Obex.DigestChallengeOptions,System.String)">
            <summary>
            Create the Digest Challenge header value.
            </summary>
            -
            <param name="nonce">Array of bytes representing the nonce.  
            Must be 16-bytes long.
            </param>
            <param name="options">Challenge information options.
            </param>
            <param name="realm">An optional displayable string indicating which 
            userid and/or password to use.  Can be <see langword="null"/>.
            </param>
            -
            <returns>An array of bytes containing the type-length-value-encoded digest-challenge.
            </returns>
        </member>
        <member name="M:Brecham.Obex.Authentication.ParseDigestChallengeHeader(System.Byte[],System.Byte[]@,Brecham.Obex.DigestChallengeOptions@,System.String@)">
            <summary>
            Parse a Digest Challenge header value.
            </summary>
            -
            <param name="value">An array of bytes containing the type-length-value-encoded 
            digest-challenge.
            </param>
            <param name="nonce">On return contains an array of bytes representing the nonce.  
            Will be 16-bytes long, or <see langword="null"/> if the header does not 
            contain this field.  The point of the digest-challenge is to carry this value 
            so it would be senseless if the value wasn&#x2019;t present however.
            </param>
            <param name="options">On return will contain Challenge information options.
            </param>
            <param name="realm">On return an optional displayable string indicating which 
            userid and/or password to use.  Can be <see langword="null"/>.
            </param>
        </member>
        <member name="M:Brecham.Obex.Authentication.CreateDigestResponseHeader(System.Byte[],System.Byte[])">
            <summary>
            Create the Digest Response header value.
            </summary>
            -
            <param name="requestDigest">Array of bytes representing the nonce.  
            Must be 16-bytes long.
            </param>
            <param name="challengeNonce">An optional array of bytes representing 
            the nonce from the challenge that is being responded too.  
            Must be either <see langword="null"/> or 16-bytes long.
            </param>
            -
            <remarks><para>Note that we don&#x2019;t accept a value for the 
            &#x201C;User Id&#x201D; field.  The specification doesn&#x2019;t define 
            how it should be encoded (ASCII?), and it is likely rarely used anyway.
            </para>
            </remarks>
            -
            <returns>An array of bytes containing the type-length-value-encoded digest-response.
            </returns>
        </member>
        <member name="M:Brecham.Obex.Authentication.CreateDigestResponse(System.Byte[],System.String)">
            <summary>
            Create the request digest secure hash of the passphrase
            for the authentication response.
            </summary>
            -
            <param name="nonce">A byte-array containing 
            the nonce value as received in the authentication challenge.
            Must be 16-bytes long.
            </param>
            <param name="passphrase">A <see cref="T:System.String"/> containing 
            the password/phrase.  We assume it is ASCII text.
            </param>
            -
            <returns>A byte-array containing the resultant secure hash.
            </returns>
            -
            <exception cref="T:System.Text.EncoderFallbackException">
            The given string is not in ASCII format.
            </exception>
            -
            <remarks>
            <para>Note the OBEX specification (OBEX13.pdf) contain no description 
            of what character set or encoding is to be used for the passphrase, or 
            whether the same charset+bytes encoding as the &#x201C;realm&#x201D; value.  
            Here we assume ASCII and will reject any string containing non-ASCII characters 
            (at least on platforms that support that: NETCF and Mono don't support 
            strict string encoding).  Consider using the overload that takes a 
            byte-array if you share the binary format as the server.
            </para>
            </remarks>
        </member>
        <member name="M:Brecham.Obex.Authentication.CreateDigestResponse(System.Byte[],System.Byte[])">
            <summary>
            Create the request digest secure hash of the passphrase
            for the authentication response.
            </summary>
            -
            <param name="nonce">A byte-array containing 
            the nonce value as received in the authentication challenge.
            Must be 16-bytes long.
            </param>
            <param name="passphrase">A byte-array containing 
            the password/phrase.
            </param>
            -
            <returns>A byte-array containing the resultant secure hash.
            </returns>
        </member>
        <member name="M:Brecham.Obex.Authentication.ParseDigestResponseHeader(System.Byte[],System.Byte[]@,System.Byte[]@,System.Byte[]@)">
            <summary>
            Parse a Digest Response header value.
            </summary>
            -
            <param name="value">An array of bytes containing the type-length-value-encoded 
            digest-response.
            </param>
            <param name="requestDigest">On return an array of bytes representing the digest.  
            Will be 16-bytes long, or <see langword="null"/> if the header does not 
            contain this field.  The point of the digest-response is to carry this value 
            so it would be senseless if the value wasn&#x2019;t present however.
            </param>
            <param name="userId">On return an optional array of bytes representing 
            the UserId value.  Can be <see langword="null"/>.
            </param>
            <param name="nonce">On return an optional array of bytes representing 
            the nonce that was used in calculating the digest.
            Will be 16-bytes long, or <see langword="null"/> if the header did not 
            contain it.
            </param>
        </member>
        <member name="T:Brecham.CrossPlatform.Miscellaneous">
            <exclude/>
        </member>
        <member name="M:Brecham.CrossPlatform.Miscellaneous.IsMonoRuntime">
            <exclude/>
        </member>
        <member name="T:Brecham.CrossPlatform.ExceptionFactory">
            <exclude/>
        </member>
        <member name="M:Brecham.CrossPlatform.ExceptionFactory.ArgumentOutOfRangeException(System.String,System.String)">
            <exclude/>
        </member>
        <member name="T:Brecham.CrossPlatform.StringUtilities">
            <exclude/>
        </member>
        <member name="M:Brecham.CrossPlatform.StringUtilities.IsNullOrEmpty(System.String)">
            <exclude/>
        </member>
        <member name="T:Brecham.Obex.ObexConstant">
            <summary>
            Well-known values used with the OBEX protocol.  These include values for 
            use in the Target or Who headers to select which service/application to 
            access, values for use in the Type to indicate the media type of the content,
            and other miscellaneous values.
            The Target and Type values are defined in 
            <see cref="T:Brecham.Obex.ObexConstant.Target"/> and
            <see cref="T:Brecham.Obex.ObexConstant.Type"/> respectively.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexConstant.TcpPortNumber">
            <summary>
            "This port number should be used when
            transporting OBEX protocol data over a TCP network. More specifically, 
            it represents the location of the
            default OBEX server in the TCP network.", 
            from OBEX13.pdf, section 6.3.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexConstant.FileNameIrMCLog">
            <summary>
            <c>telecom/pb/info.log</c>.
            IrMC Information Log.
            Referenced in OBEX13.pdf section 8.5.
            </summary>
        </member>
        <member name="T:Brecham.Obex.ObexConstant.Type">
            <summary>
            Well-known Media Type values defined (or at least referenced) in the OBEX 
            specification.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexConstant.Type.TextVcard">
            <summary>
            <c>text/x-vCard</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexConstant.Type.Capability">
            <summary>
            <c>x-obex/capability</c>.  See OBEX13.pdf, section 8.5.
            </summary>
            <remarks>
            From OBEX13.pdf:
            <p>&#x201C;8.5.1 The Capability Object/Database</p>
            <p>[&#x2026;]
            The capability object contains object information such as what objects
            the device supports and which ones can be PUT to the inbox. It contains
            general-purpose information such as the devices serial number and
            manufacturer. It also contains a specification of service connection
            procedures for the various services available on a device. Such as,
            CONNECT Target Header values and Alternate LSAPs where the service
            is available.
            </p>
            <p>[&#x2026;]&#x201D;</p>
            <p>&#x201C;8.5.3.1 Requesting the Capability Object</p>
            <p>The capability object is requested by sending a GET request with
            the MIME type of the capability object provided in an OBEX <c>Type</c>
            header. The MIME type of the capability object is 
            &#x201C;x-obex/capability&#x201D;. A successful response will contain
            one or more OBEX Body headers with the full capability object as
            their contents.
            &#x201D;</p>
            </remarks>
        </member>
        <member name="F:Brecham.Obex.ObexConstant.Type.ObjectProfile">
            <summary>
            <c>x-obex/object-profile</c>.  See OBEX13.pdf, section 8.5.
            </summary>
            <remarks>
            From OBEX13.pdf:
            <p>&#x201C;8.5.2 The Object Profile Database</p>
            <p>The object profile database works in conjunction with the capability
            object to provide information about individual objects. It is
            designed to allow a client to retrieve specific information about
            the level of support that is provided for a specific object. The
            server builds an object profile for each object that the device 
            wants to support in the object database. An object profile contains
            the same information as the IrMC protocol provides in the info.log
            file, object fields section. Under IrMC, this vital information is
            hidden from most services because of its obscure location. By supplying
            this information in a service independent manner, the information
            is more useful.</p>
            <p>[&#x2026;]&#x201D;</p>
            <p>&#x201C;8.5.3.2 Requesting an Object Profile</p>
            <p>The format for an object profile object request is based on the
            MIME type of the object for which the profile is requested. A GET
            request containing the MIME type of the object whose profile is
            desired in a <c>Name</c> header, with a <c>Type</c> header containing the value
            &#x201C;x-obex/object-profile&#x201D; is interpreted by the capability
            service as an object profile request. A successful response will
            contain one or more Body headers with the object profile object
            contents.&#x201D;</p>
            </remarks>
        </member>
        <member name="F:Brecham.Obex.ObexConstant.Type.FolderListing">
            <summary>
            <c>x-obex/folder-listing</c>.  See OBEX13.pdf, section 8.1.1.1.
            </summary>
            <remarks>
            To download a folder listing connect to Target 
            <see cref="P:Brecham.Obex.ObexConstant.Target.FolderBrowsing"/>
            and do a GET for the unnamed object of this Type.
            <para>
            Of course the library contains folder-listing parsing abilities, see
            <see cref="T:Brecham.Obex.Objects.ObexFolderListingParser"/>.</para>
            </remarks>
            <seealso cref="T:Brecham.Obex.Objects.FolderListing"/>
            <seealso cref="T:Brecham.Obex.Objects.ObexFolderListingParser"/>
        </member>
        <member name="T:Brecham.Obex.ObexConstant.Target">
            <summary>
            Well-known values for use in the Target header usually at Connect time.
            They select which service or application is required, for instance the
            default Inbox service, or the Folder Browsing service for instance.
            </summary>
        </member>
        <member name="P:Brecham.Obex.ObexConstant.Target.FolderBrowsing">
            <summary>
            The Target value for the Folder Browsing service,
            where one can use
            PUT, GET, and SETPATH to browse the server's hierarchical object store.
            </summary>
            <remarks>
            <para>
            The Target value for the Folder Browsing service 
            (UUID <c>F9EC7BC4-953C-11d2-984E-525400DC9E09</c>),
            see OBEX13.pdf, section 8.1,
            where one can use
            PUT, GET, and SETPATH to browse the server's hierarchical object store.
            </para><para>
            A folder listing can be requested by doing a GET for the unnamed object
            of type 
            <see cref="F:Brecham.Obex.ObexConstant.Type.FolderListing"/>
            (<c>x-obex/folder-listing</c>).
            </para>
            <para>
            Of course the library contains folder-listing parsing abilities, see
            <see cref="T:Brecham.Obex.Objects.ObexFolderListingParser"/>.</para>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.ObexConstant.Target.IrMC">
            <summary>
            The Target value for the Level 4 IrMC service, <c>IRMC-SYNC</c>. 
            See OBEX13.pdf, section 8.3.
            </summary>
        </member>
        <member name="P:Brecham.Obex.ObexConstant.Target.SyncML">
            <summary>
            The Target value for the SyncML service, <c>SYNCML-SYNC</c>. 
            Referenced in OBEX13.pdf, section 12.4.
            </summary>
        </member>
        <member name="T:Brecham.Obex.ObexClientSession">
            <summary>
            A client-side connection to an OBEX server, supports Put, Get, and most 
            other operation types.
            </summary>
            <example>
            A simple example of sending a file is included below.
            <code lang="Visual Basic">
            Option Strict On
            Option Explicit On
            
            Imports System
            Imports System.IO   'e.g. FileStream, File, etc.
            
            Imports Brecham.Obex
            
            Imports InTheHand.Net           'e.g. IrDAEndPoint
            Imports InTheHand.Net.Sockets   'e.g. IrDAClient
            ' Available from http://32feet.net/.
            
            
            Class VbPutSampleSample
               Public Shared Sub Main(ByVal args() As String)
                  ' Open file as selected by the user
                  If args.Length &lt;&gt; 1 Then
                     Console.WriteLine("No filename given.")
                     Exit Sub
                  End If
                  Dim filename As String = args(0)
                  Using srcFile As FileStream = File.OpenRead(filename)
                     ' Connect
                     Dim cli As New IrDAClient("OBEX")
                     Dim sess As New ObexClientSession(cli.GetStream, 4096)
                     sess.Connect()
                     ' And Send
                     Dim name As String = Path.GetFilename(filename)
                     Dim contentLength As Int64 = srcFile.Length
                     sess.PutFrom(srcFile, name, Nothing, contentLength)
                     cli.Close()
                  End Using
               End Sub
            End Class
            </code></example>
            --
            <remarks>
            Every operation that communicates with the peer OBEX server can throw a
            variety of exceptions, they are:
            <see cref="T:System.IO.IOException"/>, 
            <see cref="T:Brecham.Obex.ObexResponseException"/>, and
            <see cref="T:System.Net.ProtocolViolationException"/>.
            The first of course occurs if the network connection fails, and thus the
            OBEX connection is no longer usable.
            The second occurs if the server returns an error response code to a particular
            operation.  In many cases this is not a terminal condition and more operations
            can be attempted subsequently.  For instance a GET for a particular named
            object can fail in this way (hopefully) with response code
            <see cref="F:Brecham.Obex.Pdus.ObexResponseCode.NotFound"/> if the requested
            object does not exist.  There is no need to close the connection at this
            point another operation can then be attempted.
            Finally <c>ProtocolViolationException</c> occurs when the format of the
            OBEX packet received from the peer is invalid.  In that case it is not possible
            to know what state the connection is in, so the connection should be closed.
            </remarks>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.InvalidConnectionId">
            <summary>
            OBEX13.pdf Section 2.2.11.  The value reserved to represent an invalid
            value, for instance where no Connection Identifier is in use on a connection.
            </summary>
            <seealso cref="P:Brecham.Obex.ObexClientSession.ConnectionId"/>
            <seealso cref="M:Brecham.Obex.ObexClientSession.ClearConnectionId"/>
            <seealso cref="M:Brecham.Obex.ObexClientSession.TryGetConnectionId(System.Int32@)"/>
            <!--seealso cref="F:Brecham.Obex.ObexClientSession.InvalidConnectionId"/-->
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ErrorMsgRcvdPduBiggerThanMruSizedBuffer">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ErrorMsgConnectTargetEmpty">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ErrorMsgInvalidConnectionId">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ErrorMsgPutLengthRange">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ErrorMsgReadPduEndOfStream">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ErrorMsgOperationAlreadyInProgress">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ErrorMsgThisOperationNotInProgress">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ErrorMsgNoOperationInProgress">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ErrorMsgAbortingInProgress">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.AbortMsgErrorOnWriteBodyStream">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.AbortMsgErrorOnReadBodyStream">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ErrorMsgGetFinalNoEndOfBody">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ErrorMsgMustHaveName">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ErrorMsgDeleteMustNotBodiesHeader">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Initializes a new instance of the <c>ObexClientSession</c> class
            using the given <see cref="T:System.IO.Stream"/> and buffer size.
            </summary>
            <param name="stream">A <see cref="T:System.IO.Stream"/> that is connected 
            to the peer OBEX server.</param>
            <param name="bufferSize">What size of buffer we will use to receive 
            packets (PDUs) from the peer.
            The maximum size supported by OBEX is 65535, i.e. 
            <c>UInt16.</c><see cref="F:System.UInt16.MaxValue"/>.</param>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.#ctor(System.IO.Stream,Brecham.Obex.Pdus.ObexPduFactory)">
            <summary>
            Initializes a new instance of the <c>ObexClientSession</c> class
            using the given <see cref="T:System.IO.Stream"/> and <see cref="T:Brecham.Obex.PduFactory"/>.
            </summary>
            <param name="stream">A <see cref="T:System.IO.Stream"/> that is connected 
            to the peer OBEX server.</param>
            <param name="pduFactory">A <see cref="T:Brecham.Obex.PduFactory"/> which
            shall be used to Create and Parse all PDUs sent and received by the session.</param>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Dispose">
            <summary>
            Releases all resources used by the session, in particular releases the 
            underlying stream, unless the 
            <see cref="P:Brecham.Obex.ObexClientSession.CloseInput"/> 
            property is <c>false</c>.
            </summary>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Dispose(System.Boolean)">
            <summary>
            Releases all resources used by the session, in particular releases the 
            underlying stream, unless the 
            <see cref="P:Brecham.Obex.ObexClientSession.CloseInput"/> 
            property is <c>false</c>.
            </summary>
            <param name="disposing">
            <c>true</c> if disposing, <c>false</c> is finalizing.
            </param>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.SetOperation(Brecham.Obex.ObexClientSession.ActiveOperation)">
            <summary>
            Note the start of a new operation. Fails if another operation is already in progress.
            </summary>
            <remarks>
            <para>
            To ensure that only a single operation is active at one time we bracket
            each operation in a SetOperation() EndOperation() pair.  For instance for PUT creating
            an ObexPutStream the creator function here calls <c>SetOperation(ActiveOperation.PutStream);</c>
            And the ObexPutStream calls 
              <c>ParentSession.EndOp(ObexClientSession.ActiveOperation.GetStream);</c>
            whenever it finishes -- whether on completion or error.
            </para><para>
            Thus SetOperation is only called locally, but EndOp is also called from peer classes
            (eg ObexPutStream), we also want any derived classes to be able to call these 
            methods, and finally we want to Test the effect of various SetOperation/EndOperation pairs 
            so the methods need to be "protected" / "protected internal" respectively.
            </para>
            </remarks>
            -
            <param name="op">
            The operation being started, as an
            <see cref="T:Brecham.Obex.ObexClientSession.ActiveOperation"/>.
            </param>
            -
            <exception cref="T:System.InvalidOperationException">
            Another operation is already in progress.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.EndOperation(Brecham.Obex.ObexClientSession.ActiveOperation)">
            <summary>
            Notes the end of an operation.
            </summary>
            -
            <remarks>
            Called by classes in Session Streams (eg ObexPutStream).
            </remarks>
            -
            <param name="op">
            The operation being ended, as an 
            <see cref="T:Brecham.Obex.ObexClientSession.ActiveOperation"/>
            </param>
            -
            <exception cref="T:System.InvalidOperationException">
            That operation, or no operation, was already in progress.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.EndOperation(Brecham.Obex.ObexClientSession.ActiveOperation,System.Boolean)">
            <summary>
            Notes the end of an operation.
            </summary>
            -
            <remarks>
            Called by classes in Session Streams (eg ObexPutStream).
            </remarks>
            -
            <param name="op">
            The operation being ended, as an 
            <see cref="T:Brecham.Obex.ObexClientSession.ActiveOperation"/>
            </param>
            <param name="strictOneEnd">
            Whether to fail if no operation was in progess; that would likely be
            because the operation has just cancelled itself from a different code path.
            The error is only produced in DEBUG builds anyway.
            </param>
            -
            <exception cref="T:System.InvalidOperationException">
            A different operation was in progress.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.SetSimpleOperation">
            <summary>
            Note the start of a simple single-step operation.
            Fails if another operation is already in progress.
            </summary>
            -
            <remarks>
            If the operation instead takes more than one command, then use
            <see cref="M:Brecham.Obex.ObexClientSession.SetOperation(Brecham.Obex.ObexClientSession.ActiveOperation)"/> followed by
            <see cref="M:Brecham.Obex.ObexClientSession.EndOperation(Brecham.Obex.ObexClientSession.ActiveOperation)"/>.
            </remarks>
            -
            <exception cref="T:System.InvalidOperationException">
            Another operation is already in progress.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.CheckResponseCode(Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.Pdus.ObexResponseCode[])">
            <summary>
            Check whether the response code in the received PDU is as expected.
            If not an error occurs.
            </summary>
            <param name="responseCode">
            The response code from the PDU.
            </param>
            <param name="headers">
            The headers from the PDU, as a <see cref="T:Brecham.Obex.ObexHeaderCollection"/>.
            The headers are used in creating the <c>ObexResponseException</c> if the 
            response code is not as expected, in particular for the <c>Description</c>
            header.
            </param>
            <param name="expected">
            The expected response code, as a 
            <see cref="T:Brecham.Obex.Pdus.ObexResponseCode"/>.
            </param>
            <param name="acceptableExpected">
            Optionally any other response code that are acceptable.  For instance
            the &#x201C;Wireless Link&#x201D; IrDA Obex server in Windows 2000 etc
            returns a <c>Success</c> code during the PUT operation when it should
            return a <c>Continue</c> code.
            </param>
            --
            <exception cref="T:Brecham.Obex.ObexResponseException">
            The response code is not one the expected response codes.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.WriteOneReadOneResponseIs(Brecham.Obex.Pdus.ObexCreatedPdu,System.Boolean,Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.Pdus.ObexResponseCode[])">
            <summary>
            Carries out one request/response pair, ensure only one command is in
            progress at any time, and checks that the response code is as expected.
            </summary>
            <param name="writePdu"></param>
            <param name="isResponseToConnect"></param>
            <param name="expected">
            The expected response code in the received PDU, as a 
            <see cref="T:Brecham.Obex.Pdus.ObexResponseCode"/>.
            </param>
            <param name="acceptableExpected">
            Optionally any other response code that are acceptable.  For instance
            the &#x201C;Wireless Link&#x201D; IrDA Obex server in Windows 2000 etc
            returns a <c>Success</c> code during the PUT operation when it should
            return a <c>Continue</c> code.
            </param>
            --
            <returns>
            An instance of <see cref="T:Brecham.Obex.Pdus.ObexParsedResponsePdu"/>
            containing the received PDU.
            </returns>
            -
            <exception cref="T:Brecham.Obex.ObexResponseException">
            The response code is not one the expected response codes.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Abort has been called previously and has not completed.
            </exception>
            <exception cref="T:System.IOException">
            Any <c>IOException</c> that can occur on writing to or reading from a 
            <c>Stream</c>.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.write(Brecham.Obex.Pdus.ObexCreatedPdu)">
            <summary>
            Send a PDU to the peer.  Blocks until it has been written to the 
            <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="pdu">The PDU to be sent, as a CreatedPdu.</param>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.readPdu(System.Byte[]@,System.Int32@)">
            <summary>
            Reads a complete OBEX PDU from the <see cref="T:System.IO.Stream"/>, blocking until all the 
            whole PDU has arrived.  OBEX PDUs are length-delimited.
            </summary>
            <param name="buf">The received PDU, starts at offset zero.</param>
            <param name="pduLength">The length of the PDU.</param>
            <exception cref="T:System.IO.EndOfStreamException">The end of the 
            <see cref="T:System.IO.Stream"/> was reached but the complete PDU hadn't been received.
            </exception>
            <exception cref="T:System.Net.ProtocolViolationException">
            The received PDU is bigger than the receive buffer.  This
            should not happen, as we told the peer at connect time
            what size our buffer was.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.TryGetConnectionId(System.Int32@)">
            <summary>
            Gets the Connection Id using the TryParse pattern.
            </summary>
            <param name="connectionId">When this method returns, contains the 
            Connection Id, if one was set previously, or an undefined value if
            none was set. </param>
            <returns>
            true if the Connection Id is set; otherwise, false. 
            </returns>
            <seealso cref="P:Brecham.Obex.ObexClientSession.ConnectionId"/>
            <seealso cref="M:Brecham.Obex.ObexClientSession.ClearConnectionId"/>
            <seealso cref="F:Brecham.Obex.ObexClientSession.InvalidConnectionId"/>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.ClearConnectionId">
            <summary>
            Resets the Connection Id.  No Connection Id will be added to any 
            subsequent commands sent to the peer.
            </summary>
            <seealso cref="P:Brecham.Obex.ObexClientSession.ConnectionId"/>
            <seealso cref="M:Brecham.Obex.ObexClientSession.TryGetConnectionId(System.Int32@)"/>
            <seealso cref="F:Brecham.Obex.ObexClientSession.InvalidConnectionId"/>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.AddConnectionIdIf(Brecham.Obex.ObexHeaderCollection)">
            <summary>
            If the current session/connection has a Connection Id, probably returned 
            by the server in Connect, add it to the given header collection which is to be
            sent in the PDU.
            </summary>
            <param name="headers">The ObexHeaderCollection to add the 
            Connnection Id to.  It must be non-null.</param>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Connect">
            <overloads>
            Connect, optionally to a specified OBEX service / application.
            </overloads>
            <summary>
            Connect to the default OBEX service, the Inbox.
            </summary>
            -
            <remarks>
            <para>See the overload taking a byte array
            (<see cref="M:Brecham.Obex.ObexClientSession.Connect(System.Byte[])"/>)
            for information on how to connect to the default/inbox/push OBEX server
            and how to connect to the FolderBrowsing/FTP OBEX server.
            </para>
            </remarks>
            -
            <example>
            See the examples in <see 
            cref="M:Brecham.Obex.ObexClientSession.PutFrom(System.IO.Stream,System.String,System.String,System.Int64)"/>
            and <see 
            cref="M:Brecham.Obex.ObexClientSession.GetTo(System.IO.Stream,System.String,System.String)"/>
            for examples of connecting.  The former shows a connect to the default
            OBEX Inbox service using this overload,
            and the latter shows a connection to the Folder-Browsing service.
            </example>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Connect(System.Byte[])">
             <summary>
             Connect to the specified target OBEX service/application, 
             this is known as a Directed Connect in OBEX.
             </summary>
             <remarks>
             <para>We verify that the peer has accepted the Directed Connect by 
             checking its response for a <see cref="F:Brecham.Obex.ObexHeaderId.Who"/>
             header with the given Target value,
             and raise an exception otherwise.</para> 
             <para>In either case if the response contains a 
             <see cref="F:Brecham.Obex.ObexHeaderId.ConnectionId"/> header 
             then the value is stored to use in any subsequent requests.</para>
             <note>
             <para>For the Default/Inbox OBEX server, one uses:</para>
             <list type="bullet">
             <item><term>IrDA Service Name</term>
             <description>OBEX</description>
             </item>
             <item><term>Bluetooth Profile</term>
             <description>Object Push Profile (OPP)</description>
             </item>
             <item><term>Bluetooth UUID</term>
             <description><c>BluetoothService.ObexObjectPush</c></description>
             </item>
             <item><term>OBEX Connect Target</term>
             <description>blank i.e. use <c>ObexClientSession.Connect()</c></description>
             </item>
             </list>
            <para>For the Folder Browsing Service, one uses:</para>
             <list type="bullet">
             <item><term>IrDA Service Name</term>
             <description>OBEX</description>
             </item>
             <item><term>Bluetooth Profile</term>
             <description>File Transfer Profile (FTP)</description>
             </item>
             <item><term>Bluetooth UUID</term>
             <description><c>BluetoothService.ObexFileTransfer</c></description>
             </item>
             <item><term>OBEX Connect Target</term>
             <description>
             <see cref="P:Brecham.Obex.ObexConstant.Target.FolderBrowsing"/>
             i.e. use 
             <c>ObexClientSession.Connect(ObexConstant.Target.FolderBrowsing)</c></description>
             </item>
             </list>
             <para>See also the examples.
             </para>
             </note>
             </remarks>
             <param name="target">A non-empty byte[] containing the value of the 
             <see cref="F:Brecham.Obex.ObexHeaderId.Target"/>
             header.  Some well-known values are provided, i.e.
             <see cref="P:Brecham.Obex.ObexConstant.Target.IrMC"/>, 
             <see cref="P:Brecham.Obex.ObexConstant.Target.FolderBrowsing"/>, etc.
             </param>
             -
             <exception cref="T:System.ArgumentNullException"><c>target</c> is null.</exception>
             <exception cref="T:System.ArgumentOutOfRangeException">
             <c>target</c> is zero length.</exception>
             -
             <example>
             See the examples in <see cref="M:Brecham.Obex.ObexClientSession.PutFrom(System.IO.Stream,System.String,System.String,System.Int64)"/>
             and <see cref="M:Brecham.Obex.ObexClientSession.GetTo(System.IO.Stream,System.String,System.String)"/>
             for examples of connecting.  The former shows a connect to the default
             OBEX Inbox service,
             and the latter shows a connection to the Folder-Browsing service
             using this overload.
             </example>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Connect(Brecham.Obex.ObexHeaderCollection)">
            <summary>
            Carry out a Connect operation, including the given headers in the 
            request PDU.
            </summary>
            <remarks>
            <para>For Directed applications, the headers should include
            a <see cref="F:Brecham.Obex.ObexHeaderId.Target"/> header and possibly 
            a <see cref="F:Brecham.Obex.ObexHeaderId.Who"/> header.  
            If the directed connect is accepted then the server should return these 
            similar headers in its response, however we do *no* checking of 
            the response headers, that is the caller's responsibility in this case.</para>
            <para>In either case if the response contains a
            <see cref="F:Brecham.Obex.ObexHeaderId.ConnectionId"/> header 
            then the value is stored to use in any subsequent requests.</para>
            </remarks>
            -
            <param name="headers">
            [Advanced usage]
            An <see cref="T:Brecham.Obex.ObexHeaderCollection"/>
            containing the headers to be sent in the Connect request.</param>
            -
            <returns>The PDU received in response from the server, as a 
            <see cref="T:Brecham.Obex.Pdus.ObexParsedResponsePdu"/>.</returns>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Disconnect">
            <overloads>
            Do a Disconnect command,
            optionally giving a message explaining the reason for disconnecting.
            Note that sending a disconnect command is optional, and does 
            <!--hack to get bold--><see cref="F:not"/> close the connection.
            </overloads>
            ----
            <summary>
            Do a Disconnect command.
            Note that sending a disconnect command is optional, and does 
            <!--hack to get bold--><see cref="F:not"/> close the connection.
            </summary>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Disconnect(System.String)">
            <summary>
            Do a Disconnect command giving the supplied string as the reason for disconnecting.
            Note that sending a disconnect command is optional, and does 
            <!--hack to get bold--><see cref="F:not"/> close the connection.
            </summary>
            <remarks>Note, that if the <c>reason</c> string is too large to fit within the 
            maximum size of PDU this it will be discarded and the PDU sent without it.
            </remarks>
            <param name="reason">A string containing a user readable description.</param>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Abort">
            <overloads>
            Abort any existing operation and send an Abort command to the peer,
            optionally giving a message explaining the reason for aborting.
            </overloads>
            <summary>
            Abort any existing operation and send an Abort command to the peer.
            </summary>
            <remarks>
            <para>
            Abort any existing operation and send an Abort command to the peer.
            </para><para>
            This is the only operation that it is legal to call whilst another operation is in progress.
            </para>
            </remarks>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Abort(System.String)">
            <summary>
            Abort any existing operation and send an Abort command to the peer,
            giving the supplied string as the reason for disconnecting.
            </summary>
            <remarks>
            <para>
            Abort any existing operation and send an Abort command to the peer,
            giving the supplied string as the reason for disconnecting.
            Note, that if the <c>reason</c> string is too large to fit within the 
            maximum size of PDU this it will be discarded and the PDU sent without it.
            </para><para>
            This is the only operation that it is legal to call whilst another operation is in progress.
            </para>
            </remarks>
            <param name="reason">A string containing a user readable description.</param>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.SetPathReset">
            <summary>
            Do a SetPath command asking for the current folder to be set to 
            the default folder.
            </summary>
            <remarks>
            <note>After Beta 2
            this defaults to <c>SetPathCreateFolderIfDoesNotExist.DoNotCreate</c>.</note>
            </remarks>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.SetPathUp">
            <summary>
            Do a SetPath command asking for the current folder to be set to its 
            parent folder.
            </summary>
            <remarks>
            <note>After Beta 2
            this defaults to <c>SetPathCreateFolderIfDoesNotExist.DoNotCreate</c>.</note>
            </remarks>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.SetPath(System.String)">
            <overloads>
            Do a SetPath command asking to move to the given child folder, 
            with the given options.
            </overloads>
            <summary>
            Do a SetPath command asking to move to the given child folder.
            </summary>
            <param name="folderName">A String containing the name of the child folder.</param>
            -
            <remarks>
            <note>After Beta 2
            this defaults to <c>SetPathCreateFolderIfDoesNotExist.DoNotCreate</c>.</note>
            </remarks>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.SetPath(System.Boolean,System.String,System.Boolean)">
            <summary>
            Do a SetPath command asking to move to the given child folder, 
            with the given options.
            </summary>
            <param name="backupFirst">A Boolean indication whether the folder should 
            be set to the parent before moving to the named folder.</param>
            <param name="folderName">A String containing the name of the child folder.</param>
            <param name="doNotCreateFolderIfDoesNotExist">
            Whether a new folder should be created if the named folder does not exist,
            or instead to fail in that case.</param>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.SetPath(Brecham.Obex.BackupFirst,System.String,Brecham.Obex.IfFolderDoesNotExist)">
            <summary>
            Do a SetPath command asking to move to the given child folder, 
            with the given options.
            </summary>
            <param name="backupFirst">Whether the folder should 
            be set to the parent before moving to the named folder.</param>
            <param name="folderName">A String containing the name of the child folder.</param>
            <param name="doNotCreateFolderIfDoesNotExist">
            Whether a new folder should be created if the named folder does not exist,
            or instead to fail in that case.</param>
            -
            <remarks>
            Some responses seen on unsuccessful SETPATH operations
            against third-party devices are the following:
            <list type="bullet">
            <item>
            <term>The named folder did not exist</term>
            <description>Response code 0xC4, NotFound.
            </description>
            </item>
            <item><term>The user in charge of the server disallowed the operation</term>
            <description>Response code 0xC1, Unauthorized.</description>
            </item>
            </list>
            Of course such an error response from the server is reported by an exception
            of the following form:
            <para><c>Brecham.Obex.ObexResponseException: Unexpected OBEX response code: 0xC1 (Unauthorized).</c></para>
            </remarks>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.PutFrom(System.IO.Stream,System.String,System.String)">
            <overloads>
            <c>Put</c> the contents of the given <see cref="T:System.IO.Stream"/> to the peer.
            </overloads>
            <summary>
            <c>Put</c> the contents of the given <see cref="T:System.IO.Stream"/> to the peer, 
            with the given name and type metadata.
            </summary>
            <param name="source">A <see cref="T:System.IO.Stream"/> containing the
            content to be sent.</param>
            <param name="name">A <see cref="T:System.String"/> containing any Name 
            for the content.  May be <c>null</c> if no Name header is to be sent.</param>
            <param name="type">A <see cref="T:System.String"/> containing the Media Type
            of the content.  See e.g. <see cref="T:Brecham.Obex.ObexConstant.Type"/> for 
            some well known media types.
            May be <c>null</c> if no Type header is to be sent.</param>
            <example>See an example in the 
            <see cref="M:Brecham.Obex.ObexClientSession.PutFrom(System.IO.Stream,System.String,System.String,System.Int64)"/>
            Int64 overload.</example>
            -
            <exception>For the exceptions that can occur see the <see cref="M:Brecham.Obex.ObexClientSession.PutFrom(System.IO.Stream,System.String,System.String,System.Int64)"/>
            overload.</exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.PutFrom(System.IO.Stream,System.String,System.String,System.UInt32)">
            <summary>
            <c>Put</c> the contents of the given <see cref="T:System.IO.Stream"/> to the peer, 
            with the given name, type, and length metadata.
            </summary>
            <param name="source">A <see cref="T:System.IO.Stream"/> containing the
            content to be sent.</param>
            <param name="name">A <see cref="T:System.String"/> containing any Name 
            for the content.  May be <c>null</c> if no Name header is to be sent.</param>
            <param name="type">A <see cref="T:System.String"/> containing the Media Type
            of the content.  See e.g. <see cref="T:Brecham.Obex.ObexConstant.Type"/> for 
            some well known media types.
            May be <c>null</c> if no Type header is to be sent.</param>
            <param name="length">A <see cref="T:System.UInt32"/> holding the length of the 
            content.  The is sent to the peer in the Length header.</param>
            <example>See an example in the 
            <see cref="M:Brecham.Obex.ObexClientSession.PutFrom(System.IO.Stream,System.String,System.String,System.Int64)"/>
            Int64 overload.</example>
            -
            <exception>For the exceptions that can occur see the <see cref="M:Brecham.Obex.ObexClientSession.PutFrom(System.IO.Stream,System.String,System.String,System.Int64)"/>
            overload.</exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.PutFrom(System.IO.Stream,System.String,System.String,System.Int64)">
            <summary>
            <c>Put</c> the contents of the given <see cref="T:System.IO.Stream"/> to the peer, 
            with the given name, type, and length metadata.
            </summary>
            <example>
            A simple example of sending a file is included below.
            <code lang="Visual Basic">
            Option Strict On
            Option Explicit On
            
            Imports System
            Imports System.IO   'e.g. FileStream, File, etc.
            
            Imports Brecham.Obex
            
            Imports InTheHand.Net           'e.g. IrDAEndPoint
            Imports InTheHand.Net.Sockets   'e.g. IrDAClient
            ' Available from http://32feet.net/.
            
            
            Class VbPutSampleSample
               Public Shared Sub Main(ByVal args() As String)
                  ' Open file as selected by the user
                  If args.Length &lt;&gt; 1 Then
                     Console.WriteLine("No filename given.")
                     Exit Sub
                  End If
                  Dim filename As String = args(0)
                  Using srcFile As FileStream = File.OpenRead(filename)
                     ' Connect
                     Dim cli As New IrDAClient("OBEX")
                     Dim sess As New ObexClientSession(cli.GetStream, 4096)
                     sess.Connect()
                     ' And Send
                     Dim name As String = Path.GetFilename(filename)
                     Dim contentLength As Int64 = srcFile.Length
                     sess.PutFrom(srcFile, name, Nothing, contentLength)
                     cli.Close()
                  End Using
               End Sub
            End Class
            </code></example>
            <param name="source">A <see cref="T:System.IO.Stream"/> containing the
            content to be sent.</param>
            <param name="name">A <see cref="T:System.String"/> containing any Name 
            for the content.  May be <c>null</c> if no Name header is to be sent.</param>
            <param name="type">A <see cref="T:System.String"/> containing the Media Type
            of the content.  See e.g. <see cref="T:Brecham.Obex.ObexConstant.Type"/> for 
            some well known media types.
            May be <c>null</c> if no Type header is to be sent.</param>
            <param name="length">An <see cref="T:System.Int64"/> holding the length of the 
            content, to suit the return type of <see cref="M:System.IO.Stream.GetLength"/>
            The is sent to the peer in the Length header 
            if it is less than or equal to <see cref="M:System.UInt32.MaxValue"/>.
            </param>
            -
            <exception cref="T:System.InvalidOperationException">
            Another operation is in progress.
            </exception>
            <exception cref="T:Brecham.Obex.ObexResponseException">
            The response code returned by the peer is not the one expected at that point 
            in the transfer.  This will likely indicate why the peer is unable to 
            accept the tranfer.  For instance Window&#x2019;s Wireless Link application
            returns <c>0xC3</c> <see cref="F:Brecham.Obex.Pdus.ObexResponseCode.Forbidden"/> 
            if the user does not confirm the PUT, and if the transfer fill the disk, 
            fails with <c>0xCD</c> <see cref="F:Brecham.Obex.Pdus.ObexResponseCode.EntityTooLarge"/>.
            PalmOS does not prompt the user at the beginning of the transfer, but if
            the object is too big it fails with <c>0xC1</c> <see 
            cref="F:Brecham.Obex.Pdus.ObexResponseCode.Unauthorized"/>.  Finally on 
            one model of Nokia phone I've tested against, if the object is too big the
            phone simply closes the connection.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Abort has been called previously and has not completed.
            </exception>
            <exception cref="T:System.IOException">
            Any <c>IOException</c> that can occur on writing to or reading from a 
            <c>Stream</c>.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.PutFrom(System.IO.Stream,Brecham.Obex.ObexHeaderCollection)">
            <summary>
            <c>Put</c> the contents of the given <see cref="T:System.IO.Stream"/> to the peer, 
            with the given collection of metadata.
            </summary>
            <param name="source">The Stream whose contents to send.</param>
            <param name="headers">
            [Advanced usage]
            A ObexHeaderCollection containing any metadata
            to be sent before the content, such as Name, Time etc.  Any
            Connection Id will be added automatically.</param>
            -
            <exception cref="T:System.InvalidOperationException">
            Another operation is in progress.
            </exception>
            <exception cref="T:Brecham.Obex.ObexResponseException">
            The response code returned by the peer is not the one expected at that point 
            in the transfer.  This will likely indicate why the peer is unable to 
            accept the tranfer.  For instance Window&#x2019;s Wireless Link application
            returns <c>0xC3</c> <see cref="F:Brecham.Obex.Pdus.ObexResponseCode.Forbidden"/> 
            if the user does not confirm the PUT, and if the transfer fill the disk, 
            fails with <c>0xCD</c> <see cref="F:Brecham.Obex.Pdus.ObexResponseCode.EntityTooLarge"/>.
            PalmOS does not prompt the user at the beginning of the transfer, but if
            the object is too big it fails with <c>0xC1</c> <see 
            cref="F:Brecham.Obex.Pdus.ObexResponseCode.Unauthorized"/>.  Finally on 
            one model of Nokia phone I've tested against, if the object is too big the
            phone simply closes the connection.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Abort has been called previously and has not completed.
            </exception>
            <exception cref="T:System.IOException">
            Any <c>IOException</c> that can occur on writing to or reading from a 
            <c>Stream</c>.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.PutFile(System.String)">
            <summary>
            <c>Put</c>s the contents of the given file to the peer, 
            passing its filename and length as metadata.
            </summary>
            -
            <remarks><para>This method opens the specified file and <c>Put</c>s
            it to the peer.  The file’s filename and length are sent as 
            metadata.  The filename is created by calling 
            <see cref="M:System.IO.Path.GetFileName(System.String)">Path.GetFileName</see>
            on the <paramref name="path"/> argument, and the length value is 
            the opened file’s
            <see cref="P:System.IO.FileStream.Length">FileStream.Length</see>.
            </para>
            </remarks>
            -
            <exception cref="T:System.IO.IOException">… or a similar exception produced
            on opening or reading from the <see cref="T:System.IO.FileStream"/> 
            for the source file.
            </exception>
            <exception>For the exceptions that can occur see the <see cref="M:Brecham.Obex.ObexClientSession.PutFrom(System.IO.Stream,System.String,System.String,System.Int64)"/>
            overload.</exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Put(System.String,System.String)">
            <overloads>
            Initiates a <c>Put</c> operation, 
            returning a <see cref="T:System.IO.Stream"/> that the consumer writes the content to.
            </overloads>
            --
            <summary>
            Initiates a <c>Put</c> operation 
            with the given name, type, and length metadata,
            returning a <see cref="T:System.IO.Stream"/> that the consumer writes the content to.
            </summary>
            <param name="name">A <see cref="T:System.String"/> containing any Name 
            for the content.  May be <c>null</c> if no Name header is to be sent.</param>
            <param name="type">A <see cref="T:System.String"/> containing the Media Type
            of the content.  See e.g. <see cref="T:Brecham.Obex.ObexConstant.Type"/> for 
            some well known media types.
            May be <c>null</c> if no Type header is to be sent.</param>
            <returns>An instance of <see cref="T:Brecham.Obex.ObexPutStream"/> 
            connected to the peer server.
            </returns>
            -
            <exception>For the exceptions that can occur see the <see cref="M:Brecham.Obex.ObexClientSession.Put(Brecham.Obex.ObexHeaderCollection)"/>
            overload.</exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Put(System.String,System.String,System.UInt32)">
            <summary>
            Initiates a <c>Put</c> operation
            with the given name, type, and length metadata,
            returning a <see cref="T:System.IO.Stream"/> that the consumer writes the content to.
            </summary>
            <param name="name">A <see cref="T:System.String"/> containing any Name 
            for the content.  May be <c>null</c> if no Name header is to be sent.</param>
            <param name="type">A <see cref="T:System.String"/> containing the Media Type
            of the content.  See e.g. <see cref="T:Brecham.Obex.ObexConstant.Type"/> for 
            some well known media types.
            May be <c>null</c> if no Type header is to be sent.</param>
            <param name="length">A <see cref="T:System.UInt32"/> holding the length of the 
            content.  This is sent to the peer in the Length header.</param>
            <returns>An instance of <see cref="T:Brecham.Obex.ObexPutStream"/> 
            connected to the peer server.
            </returns>
            -
            <exception>For the exceptions that can occur see the <see cref="M:Brecham.Obex.ObexClientSession.Put(Brecham.Obex.ObexHeaderCollection)"/>
            overload.</exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Put(System.String,System.String,System.Int64)">
            <summary>
            Initiates a <c>Put</c> operation
            with the given name, type, and length metadata,
            returning a <see cref="T:System.IO.Stream"/> that the consumer writes the content to.
            </summary>
            <param name="name">A <see cref="T:System.String"/> containing any Name 
            for the content.  May be <c>null</c> if no Name header is to be sent.</param>
            <param name="type">A <see cref="T:System.String"/> containing the Media Type
            of the content.  See e.g. <see cref="T:Brecham.Obex.ObexConstant.Type"/> for 
            some well known media types.
            May be <c>null</c> if no Type header is to be sent.</param>
            <param name="length">An <see cref="T:System.Int64"/> holding the length of the 
            content, this overload exists mainly suit the return type of <c>Stream.</c><see cref="M:System.IO.Stream.GetLength"/>
            This is sent to the peer in the Length header
            if it is less than or equal to <c>UInt32.</c><see cref="M:System.UInt32.MaxValue"/>
            .</param>
            <returns>An instance of <see cref="T:Brecham.Obex.ObexPutStream"/> 
            connected to the peer server.
            </returns>
            -
            <exception>For the exceptions that can occur see the <see cref="M:Brecham.Obex.ObexClientSession.Put(Brecham.Obex.ObexHeaderCollection)"/>
            overload.</exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Put(Brecham.Obex.ObexHeaderCollection)">
            <summary>
            Initiates a <c>Put</c> operation
            with the given collection metadata, 
            returning a <see cref="T:System.IO.Stream"/> that the consumer writes the content to.
            </summary>
            <param name="headers">
            [Advanced usage]
            A ObexHeaderCollection containing any metadata
            to be sent before the content, such as Name, Time etc.  Any
            Connection Id will be added automatically.</param>
            <returns>An instance of <see cref="T:Brecham.Obex.ObexPutStream"/> 
            connected to the peer server.
            </returns>
            -
            <exception cref="T:System.InvalidOperationException">
            Another operation is in progress.
            </exception>
            <exception cref="T:Brecham.Obex.ObexResponseException">
            The response code returned by the peer is not the one expected at that point 
            in the transfer.  This will likely indicate why the peer is unable to 
            accept the tranfer.  For instance Window&#x2019;s Wireless Link application
            returns <c>0xC3</c> <see cref="F:Brecham.Obex.Pdus.ObexResponseCode.Forbidden"/> 
            if the user does not confirm the PUT, and if the transfer fill the disk, 
            fails with <c>0xCD</c> <see cref="F:Brecham.Obex.Pdus.ObexResponseCode.EntityTooLarge"/>.
            PalmOS does not prompt the user at the beginning of the transfer, but if
            the object is too big it fails with <c>0xC1</c> <see 
            cref="F:Brecham.Obex.Pdus.ObexResponseCode.Unauthorized"/>.  Finally on 
            one model of Nokia phone I've tested against, if the object is too big the
            phone simply closes the connection.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Abort has been called previously and has not completed.
            </exception>
            <exception cref="T:System.IOException">
            Any <c>IOException</c> that can occur on writing to or reading from a 
            <c>Stream</c>.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.PutMetadata(Brecham.Obex.ObexHeaderCollection)">
            <summary>
            Step 1. PutFrom is done in a sequence of steps, firstly sending the metadata 
            alone, eg the Name, Length etc.  This done in this function. Secondly and 
            thirdly arte sending the content, and sending the final packet respectively.
            
            So, send the PutFrom+NonFinal PDU(s) starting the process, multiple PDUs
            being sent only if the metadata headers span more than one PDU.
            We receive Continue PDU(s) in response.
            </summary>
            <param name="headersSend">Any metadata to send with the object.</param>
            -
            <exception cref="T:Brecham.Obex.ObexResponseException">
            The response code is not one the expected response codes.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Abort has been called previously and has not completed.
            </exception>
            <exception cref="T:System.IOException">
            Any <c>IOException</c> that can occur on writing to or reading from a 
            <c>Stream</c>.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.PutContent(System.IO.Stream)">
            <summary>
            Step 2. The PUT metadata has been sent, now send the content as a number 
            of PDUs each containing a body header.  Quits at the end of the content, 
            for step 3.
            </summary>
            -
            <param name="source">A <c>Stream</c> containing the content to be sent.</param>
            -
            <exception cref="T:Brecham.Obex.ObexResponseException">
            The response code is not one the expected response codes.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Abort has been called previously and has not completed.
            </exception>
            <exception cref="T:System.IOException">
            Any <c>IOException</c> that can occur on writing to or reading from a 
            <c>Stream</c>.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.PutFinal">
            <summary>
            Step 3. Send the PutFrom+Final PDU containing the EndOfBody header, 
            and receive an Ok PDU in response.
            </summary>
            -
            <exception cref="T:Brecham.Obex.ObexResponseException">
            The response code is not one the expected response codes.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Abort has been called previously and has not completed.
            </exception>
            <exception cref="T:System.IOException">
            Any <c>IOException</c> that can occur on writing to or reading from a 
            <c>Stream</c>.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Delete(System.String)">
            <overloads>
            Delete the given file or folder.
            </overloads>
            ----
            <summary>
            Delete the given file or folder, by name.
            </summary>
            <param name="name">A <see cref="T:System.String"/> containing the 
            name of the object to delete.  It must be non-null and non
            empty.</param>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Delete(Brecham.Obex.ObexHeaderCollection)">
            <summary>
            Delete the given file or folder, identified by the metadata in the given 
            <see cref="T:Brecham.ObexLib.ObexHeaderCollection"/>.
            </summary>
            <param name="headers">
            [Advanced usage]
            An instance of 
            <see cref="T:Brecham.ObexLib.ObexHeaderCollection"/> containing the 
            metadata required to identify which object the server is to delete.
            It must not contain any body headers (<c>Body</c> or <c>EndOfBody</c>).
            </param>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.GetTo(System.IO.Stream,System.String,System.String)">
            <overloads>
            <c>Get</c>s the specified object from the peer, 
            and writes the content to the given <see cref="T:System.IO.Stream"/>.
            </overloads>
            --
            <summary>
            <c>Get</c>s the object 
            identified by the given Name, and Type metadata, 
            and writes the content to the given <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="destination">The <c>Stream</c> to which the content will be written.</param>
            <param name="name">A <see cref="T:System.String"/> containing any Name 
            for the content.  May be <c>null</c> if no Name header is to be sent.</param>
            <param name="type">A <see cref="T:System.String"/> containing the Media Type
            of the content.  See e.g. <see cref="T:Brecham.Obex.ObexConstant.Type"/> for 
            some well known media types.
            May be <c>null</c> if no Type header is to be sent.</param>
            -
            <example>
            A simple example of getting a file is included below.
            <code lang="Visual Basic">
            Option Strict On
            Option Explicit On
            
            Imports System
            Imports System.IO   'e.g. FileStream, File, etc.
            
            Imports Brecham.Obex
            
            Imports InTheHand.Net           'e.g. IrDAEndPoint
            Imports InTheHand.Net.Sockets   'e.g. IrDAClient
            ' Available from http://32feet.net/.
            
            
            Class VbGetSampleSample
                Public Shared Sub Main_SimpleNoErrorHandling(ByVal args() As String)
                    ' GET file as specified by the user
                    If args.Length &lt;&gt; 1 Then
                        Console.WriteLine("No filename given.")
                        Exit Sub
                    End If
                    Dim filename As String = args(0)
                    Using dstFile As FileStream = File.OpenWrite(filename)
                        ' Connect
                        Dim cli As New IrDAClient("OBEX")
                        Dim sess As New ObexClientSession(cli.GetStream, 4096)
                        ' Must connect to the Folder-Browsing service, as the default Inbox 
                        ' service does not support GET
                        sess.Connect(ObexConstant.Target.FolderBrowsing)
                        ' And GET
                        ' Use the complete filename given
                        Dim name As String = filename
                        sess.GetTo(dstFile, name, Nothing)
                        cli.Close()
                    End Using
                End Sub
            End Class
            </code></example>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.GetTo(System.IO.Stream,Brecham.Obex.ObexHeaderCollection)">
            <summary>
            <c>Get</c>s the object
            identified by the given collection of metadata,
            and writes the content to the given <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="destination">The <c>Stream</c> to which the content will be written.</param>
            <param name="headers">
            [Advanced usage]
            A ObexHeaderCollection containing any metadata
            to be sent in the request for the content, such as Name, Time etc.  Any
            Connection Id will be added automatically.</param>
            -
            <example>See <see cref="M:Brecham.Obex.ObexClientSession.GetTo(System.IO.Stream,System.String,System.String)"/></example>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.GetInitial(Brecham.Obex.ObexHeaderCollection,Brecham.Obex.Pdus.ObexParsedResponsePdu@,Brecham.Obex.ObexHeaderCollection)">
            <summary>
            Send the Request metadata, allowing the headers to be split 
            over multiple send+receive PDU exchanges if they're too big for 
            one send PDU.
            The peer starts sending the body (and any headers?) only once 
            we've finished writing the request; that is after our first PDU
            with the Final bit set.  So here we quit after we've no headers
            left, as the final bit will have been sent.  GetIntermediate
            expects to send our PDU as its first operation.
            </summary>
            <param name="headersSend">Any metadata to send to Get the object.</param>
            <param name="firstRspPdu">Since the response comes immediately after the
            last of the Get's containing metadata we need to pass it onto the function
            the deals with receiving the content.
            </param>
            <param name="totalRcvdHeaders">The aggregate headers returned by the peer
            server, any duplicated being discarded.</param>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.GetUseBodyResponses(Brecham.Obex.Pdus.ObexParsedResponsePdu,System.Byte[]@,Brecham.Obex.ObexHeaderCollection)">
            <summary>
            internal...
            </summary>
            <param name="rspPdu">The PDU received from the peer server in response
            to a GET request PDU, it should be a Continue containing a Body header
            or a Success containing an EndOfBody PDU.</param>
            <param name="body">The body content from the PDU.  In the case where 
            the PDU has no body (possible in a (early) Continue PDU) a fake zero 
            length array is returned.</param>
            <param name="totalRcvdHeaders">The aggregate headers returned by the peer
            server, any duplicated being discarded.</param>
            -
            <returns>Whether this is the EndOfBody/Final Response.</returns>
            -
            <exception cref="T:System.Net.ProtocolException">
            The server returned an incorrect response, in particular by including no
            end-of-body header in the final PDU.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Get(System.String,System.String)">
            <overloads>
            Initiates a <c>Get</c> operation, 
            returning a <c>Stream</c> that the consumer reads the content from.
            </overloads>
            --
            <summary>
            Initiates a <c>Get</c> operation 
            with the given Name, and Type metadata,
            returning a <c>Stream</c> that the consumer reads the content from.
            </summary>
            <param name="name">A <see cref="T:System.String"/> containing any Name 
            for the content.  May be <c>null</c> if no Name header is to be sent.</param>
            <param name="type">A <see cref="T:System.String"/> containing the Media Type
            of the content.  See e.g. <see cref="T:Brecham.Obex.ObexConstant.Type"/> for 
            some well known media types.
            May be <c>null</c> if no Type header is to be sent.</param>
            <returns>An instance of <see cref="T:Brecham.Obex.ObexGetStream"/> 
            connected to the peer server.
            </returns>
            -
            <example>See <see
            cref="M:Brecham.Obex.ObexClientSession.GetTo(System.IO.Stream,System.String,System.String)"/>
            for a example of what parameters to supply.</example>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.Get(Brecham.Obex.ObexHeaderCollection)">
            <summary>
            Initiates a <c>Get</c> operation
            with the given collection of metadata, 
            returning a <c>Stream</c> that the consumer reads the content from.
            </summary>
            <param name="headers">
            [Advanced usage]
            A ObexHeaderCollection containing any metadata
            to be sent in the request for the content, such as Name, Type, Time etc.  Any
            Connection Id will be added automatically.</param>
            <returns>An instance of <see cref="T:Brecham.Obex.ObexGetStream"/> 
            connected to the peer server.
            </returns>
        </member>
        <member name="M:Brecham.Obex.ObexClientSession.GetFolderListing">
            <summary>
            Requests the folder-listing for the current folder, 
            and returns the parsed contents as a
            <see cref="T:Brecham.Obex.Objects.ObexFolderListing"/> instance.
            </summary>
            <remarks>
            See <c>ObexFolderListingParser.</c><see
            cref="M:Brecham.Obex.Objects.ObexFolderListingParser.GetAllItems"/>
            for an example of how to use the returned folder-listing items.
            <note>
            This method is equivalent simply to series of operations in the code shown below:
            doing the respective GET operation, passing the <c>stream</c>
            to an <see cref="T:Brecham.Obex.Objects.ObexFolderListingParser"/> and calling
            its <see cref="M:Brecham.Obex.Objects.ObexFolderListingParser.GetAllItems"/>
            method.  See those two items&#x2019; documentation for 
            detailed information on the content they take and return, and the exceptions
            they can throw.
            <code lang="Visual Basic">
               ObexClientSession sess = ...
               Dim xmlStrm As Stream = sess.Get(Nothing, ObexConstant.Type.FolderListing)
               Dim parser As New ObexFolderListingParser(xmlStrm)
               Dim listing As ObexFolderListing = parser.GetAllItems
            </code>
            </note>
            </remarks>
            <returns>
            An instance of <see cref="T:Brecham.Obex.Objects.ObexFolderListing"/> 
            containing the items found in the parsing operation.
            </returns>
            <example>
            See <c>ObexFolderListingParser.</c><see
            cref="M:Brecham.Obex.Objects.ObexFolderListingParser.GetAllItems"/>
            for an example of how to use the returned folder-listing items.
            </example>
        </member>
        <member name="P:Brecham.Obex.ObexClientSession.CloseInput">
            <summary>
            Gets or sets whether the underlying <c>Stream</c> should be closed when the
            session itself is closed.  This defaults to true.
            </summary>
            <remarks>
            This is similar to the property of the same name on 
            <see cref="T:System.Xml.XmlReaderSettings"/> and, to the parameter named
            <c>ownsSocket</c> on <c>NetworkStream</c>&#x2019;s constructor
            <see cref="M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket, bool)"/>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.ObexClientSession.PduFactory">
            <summary>
            Gets the <see cref="T:Brecham.Obex.Pdus.ObexPduFactory"/> instance being
            used by this session.
            </summary>
        </member>
        <member name="P:Brecham.Obex.ObexClientSession.ConnectionId">
            <summary>
            Gets or sets the OBEX session's Connection Identifier.
            </summary>
            <remarks>
            This value is set automatically if the server includes one in its response 
            to Connect, and it shouldn't need to be 
            set in normal circumstances.  
            If a valid value has been set it will be added to any 
            subsequent commands sent to the peer.
            <c>get</c> will throw <see cref="T:System.NotSupportedException"/>, if no value 
            has been set, see <see cref="M:Brecham.Obex.ObexClientSession.TryGetConnectionId(System.Int32@)"/> for an equivalent 
            function but in the Try-Parse pattern.
            The value passed to <c>set</c> is also checked
            and if the invalid connection identifier 
            (see <see cref="F:Brecham.Obex.ObexClientSession.InvalidConnectionId"/>) is passed it will throw
            <see cref="T:System.ArgumentException"/>.  To clear the value use 
            <see cref="M:Brecham.Obex.ObexClientSession.ClearConnectionId"/>.
            </remarks>
            <seealso cref="M:Brecham.Obex.ObexClientSession.ClearConnectionId"/>
            <seealso cref="M:Brecham.Obex.ObexClientSession.TryGetConnectionId(System.Int32@)"/>
            <seealso cref="F:Brecham.Obex.ObexClientSession.InvalidConnectionId"/>
        </member>
        <member name="T:Brecham.Obex.ObexClientSession.ActiveOperation">
            <summary>
            Used to ensure that only one operation is active at any time.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ActiveOperation.Idle">
            <summary>
            No operation is active.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ActiveOperation.Simple">
            <summary>
            Any single step command (i.e. one PDU each way) operation.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ActiveOperation.Put">
            <summary>
            A PutFrom operation.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ActiveOperation.PutStream">
            <summary>
            A Put operation; ie one which returns an <c>ObexPutStream</c>.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ActiveOperation.Get">
            <summary>
            A GetTo operation.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.ActiveOperation.GetStream">
            <summary>
            A Get operation; ie one which returns an <c>ObexGetStream</c>.
            </summary>
        </member>
        <member name="T:Brecham.Obex.ObexClientSession.SetPathFlags">
            <summary>
            OBEX13.pdf, Section 3.3.6.1.
            Flags to use with the <c>SetPath</c> operation.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.SetPathFlags.None">
            <summary>
            No flags set.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.SetPathFlags.Backup">
            <summary>
            &#x201C;backup a level before applying name (equivalent to ../ on many systems)&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexClientSession.SetPathFlags.DoNotCreateIfDoesNotExist">
            <summary>
            &#x201C;Don’t create folder if it does not exist, return an error instead.&#x201D;
            </summary>
        </member>
        <member name="T:Brecham.Obex.BackupFirst">
            <summary>
            Indicate whether on a SETPATH operation that
            the server should should first change to the parent folder, 
            before moving to the named folder etc.
            </summary>
            -
            <remarks>
            Used by <see cref="M:Brecham.Obex.ObexClientSession.SetPath(Brecham.Obex.BackupFirst,System.String,Brecham.Obex.IfFolderDoesNotExist)"/>.
            </remarks>
            -
            <seealso cref="M:Brecham.Obex.ObexClientSession.SetPath(Brecham.Obex.BackupFirst,System.String,Brecham.Obex.IfFolderDoesNotExist)"/>
        </member>
        <member name="F:Brecham.Obex.BackupFirst.DoNot">
            <summary>
            Do NOT change to the parent folder first.
            </summary>
        </member>
        <member name="F:Brecham.Obex.BackupFirst.DoBackupFirst">
            <summary>
            DO change to the parent folder first, that is like doing <c>cd ..\&lt;name&gt;</c>
            on a Windows command-line.
            </summary>
        </member>
        <member name="T:Brecham.Obex.IfFolderDoesNotExist">
            <summary>
            Indicate whether on a SETPATH operation that
            a new folder should be created by the server if it doesn't already exist,
            or whether it should instead return an error in that case.
            </summary>
            -
            <remarks>
            Used by <see cref="M:Brecham.Obex.ObexClientSession.SetPath(Brecham.Obex.BackupFirst,System.String,Brecham.Obex.IfFolderDoesNotExist)"/>.
            </remarks>
            -
            <seealso cref="M:Brecham.Obex.ObexClientSession.SetPath(Brecham.Obex.BackupFirst,System.String,Brecham.Obex.IfFolderDoesNotExist)"/>
        </member>
        <member name="F:Brecham.Obex.IfFolderDoesNotExist.Create">
            <summary>
            DO create a new folder if it doesn't already exist.
            </summary>
        </member>
        <member name="F:Brecham.Obex.IfFolderDoesNotExist.Fail">
            <summary>
            Do NOT create the folder if it does not exist, return an error instead.
            </summary>
        </member>
        <member name="T:Brecham.Obex.Pdus.ObexCreateTooLongException">
            <summary>
            The exception that is thrown when creating a PDU that is too long for
            the buffer.  It is thrown by ObexPduFactory.Create and its 
            overloads.
            </summary>
            <remarks>
            See <c>ObexPduFactory.</c><see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>
            for more detail but an error is only produced when not even the first 
            header will not fit in the PDU buffer.  Otherwise as many header as 
            possible are added, the PDU is returned, and then another PDU can be
            created with the remaining headers.
            </remarks>
            <preliminary/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexCreateTooLongException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ObexCreateTooLongException class 
            with a specified message that describes the error.
            </summary>
            <param name="message">The message that describes the exception.</param>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexCreateTooLongException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <c>ObexCreateTooLongException</c> class
            from the specified instances of the <c>SerializationInfo</c> and 
            <c>StreamingContext</c> classes. 
            </summary>
            <param name="info">
            A <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that 
            contains the information required to serialize the 
            new <see cref="T:Brecham.Obex.Pdus.ObexCreateTooLongException"/> instance. 
            </param>
            <param name="context">
            A <see cref="T:System.Runtime.Serialization.StreamingContext"/> that 
            indicates the source of the serialized stream associated with the new 
            <c>ObexCreateTooLongException</c>instance. 
            </param>
        </member>
        <member name="T:Brecham.Obex.ObexResponseException">
            <summary>
            The exception that is thrown when an error occurs while accessing the 
            network through the OBEX protocol.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexResponseException.ErrorMsgPrefixUnexpectedResponseCode">
            <summary>
            The prefix on the exception message.
            </summary>
            <remarks>
            The prefix on the exception message.  Example messages are as the following.
            <code>
            Unexpected OBEX response code: 0xC0 (BadRequest).
            Unexpected OBEX response code: 0xD1 (NotImplemented).
            Unexpected OBEX response code: 0xD2 (210).
            Unexpected OBEX response code: 0x39 (57), Reason: GET operation not supported.
            </code>
            Note in the latter examples we don't recognise the response code value and 
            thus have not provided a textual translation, and in the last the peer supplied
            a reason message in a description header.
            </remarks>
        </member>
        <member name="M:Brecham.Obex.ObexResponseException.#ctor(Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection)">
            <summary>
            Initializes a new instance of the ObexResponseException class 
            with the specified error response code, and any descriptive text
            returned by the peer.
            </summary>
            <param name="code">One of the ObexResponseCode values; 
                as returned by the peer.</param>
            <param name="headers">An OBEX header collection; from the response
                which may contain a Description header.</param>
        </member>
        <member name="M:Brecham.Obex.ObexResponseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <c>ObexResponseException</c> class
            from the specified instances of the <c>SerializationInfo</c> and 
            <c>StreamingContext</c> classes. 
            </summary>
            <param name="info">
            A <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that 
            contains the information required to serialize the 
            new <see cref="T:Brecham.Obex.Pdus.ObexCreateTooLongException"/> instance. 
            </param>
            <param name="context">
            A <see cref="T:System.Runtime.Serialization.StreamingContext"/> that 
            indicates the source of the serialized stream associated with the new 
            <c>ObexResponseException</c>instance. 
            </param>
        </member>
        <member name="M:Brecham.Obex.ObexResponseException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Populates a <c>SerializationInfo</c> with the data needed to serialize 
            the target object. 
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to 
            populate with data.
            </param>
            <param name="context">
            A <see cref="T:System.Runtime.Serialization.StreamingContext"/> that 
            specifies the destination for this serialization.
            </param>
        </member>
        <member name="P:Brecham.Obex.ObexResponseException.Message">
            <summary>
            The error message that explains the reason for the exception.  
            It will contain the OBEX response code that the peer returned, and 
            any descriptive text that it returned.
            </summary>
        </member>
        <member name="P:Brecham.Obex.ObexResponseException.ResponseCode">
            <summary>
            Gets the response code from the server's error PDU.
            </summary>
        </member>
        <member name="P:Brecham.Obex.ObexResponseException.Description">
            <summary>
            Gets the Description text from the error PDU received 
            from the server.
            If no Description header exists in the error PDU this will return 
            <c>null</c>.
            </summary>
        </member>
        <member name="P:Brecham.Obex.ObexResponseException.Headers">
            <summary>
            Gets the headers from the error PDU received from the server.
            </summary>
            -
            <remarks>
            <para>An empty collection is returned if no headers were present 
            in the response.  That is, this property never returns <see langword="null"/>.
            </para>
            <para>Note that the headers are currently not handled by Runtime Serialization 
            and will be empty when deserialized.  So if you store the exception or 
            handle it in another AppDomain then the headers will be missing.
            </para>
            </remarks>
        </member>
        <member name="T:Brecham.Obex.ForV1CloseDisposeLikeV2Stream">
            <exclude/>
            <summary>
            An internal abstract <see cref="T:System.IO.Stream"/> used to implement some of the 
            Close/Dispose functionality from FXv2 when compiling the library for FXv1.1.
            </summary>
        </member>
        <member name="T:Brecham.Obex.AbortableStream">
            <summary>
            An abstract <see cref="T:System.IO.Stream"/> containing the functionality
            common to the <see cref="T:Brecham.Obex.ObexPutStream"/> and 
            <see cref="T:Brecham.Obex.ObexGetStream"/> .
            </summary>
        </member>
        <member name="M:Brecham.Obex.AbortableStream.#ctor(Brecham.Obex.ObexClientSession)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.AbortableStream.Dispose(System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.AbortableStream.CloseCore(System.Boolean)">
            <summary>
            Called from both Close/Dispose and Abort etc etc... ...
            </summary>
            <remarks>
            <para>
            Can do a clean graceful close, or a non-graceful close where the operation 
            is (has been) abandoned.</para>
            <para>In a <c>PUT</c> operation for instance, the non-graceful close
            does not send the final PutFinal+EndOfBody command.</para>
            </remarks>
            <param name="graceful">Whether this a clean normal end of the stream
            <c>Close</c>.  Otherwise it's called from elsewhere, <c>Abort</c> for instance, 
            and is *not* a clean close.  It shouldn't send any PDU requests that 
            continue the operation.
            </param>
        </member>
        <member name="M:Brecham.Obex.AbortableStream.VerifyIsOpen(System.String)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.AbortableStream.Abort">
            <summary>
            Abort the operation, doing whatever is necessary to signal this to the peer.
            </summary>
        </member>
        <member name="M:Brecham.Obex.AbortableStream.Abort(System.String)">
            <summary>
            Abort the operation, doing whatever is necessary to signal this to the peer.
            Supplying the given reason <see cref="T:System.String"/> indicating why.
            </summary>
        </member>
        <member name="M:Brecham.Obex.AbortableStream.CreateDisposedFromInvalidOperationException(System.InvalidOperationException)">
            <summary>
            Create an ObjectDisposedException wrapping the given InvalidOperationException.
            </summary>
            <remarks>
            There are different supported constructors on the full and CF frameworks,
            so we require this to cope with that.  On the NETCF the caught 'inner
            exception' cannot be set on the new exception.
            </remarks>
            <param name="innerException">
            The caught exception to be wrapped.
            </param>
            <returns>The new <see cref="T:System.ObjectDisposedException"/>
            wrapping the caught <see cref="T:System.InvalidOperationException"/>
            and to be thrown in its stead.
            </returns>
        </member>
        <member name="M:Brecham.Obex.AbortableStream.Seek(System.Int64,System.IO.SeekOrigin)">
             <summary>
             Sets the current position of the stream to the given value.
            
             This method is not currently supported and always throws a 
             <see cref="T:System.NotSupportedException"/>.
             </summary>
        </member>
        <member name="M:Brecham.Obex.AbortableStream.SetLength(System.Int64)">
            <summary>
            Overridden. Sets the current position of the stream to the given value. 
            
            This method is not currently supported and always throws a 
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:Brecham.Obex.AbortableStream.ParentSession">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.AbortableStream.IsOpen">
            <summary>
            Gets whether the <c>Stream</c> is known to be open.
            </summary>
        </member>
        <member name="P:Brecham.Obex.AbortableStream.CanSeek">
            <summary>
            Overridden. Gets a value that indicates whether the stream supports seeking. 
            This is always false.
            </summary>
        </member>
        <member name="P:Brecham.Obex.AbortableStream.Length">
            <summary>
            Overridden. Gets the length of the data available on the stream.
            
            This property is not currently supported and always throws a 
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:Brecham.Obex.AbortableStream.Position">
            <summary>
            Gets or sets the current position in the stream.
            
            This property is not currently supported and always throws a 
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="T:Brecham.Obex.ObexPutStream">
            <summary>
            Provides the stream of content in a OBEX Put operation.
            </summary>
            <remarks>
            The <c>ObexPutStream</c> class provides methods for sending data as part of
            the Put operation.
            </remarks>
            <seealso cref="M:Brecham.Obex.ObexClientSession.Put(Brecham.Obex.ObexHeaderCollection)"/>
            <seealso cref="M:Brecham.Obex.ObexClientSession.Put(System.String,System.String)"/>
            <seealso cref="M:Brecham.Obex.ObexClientSession.Put(System.String,System.String,System.UInt32)"/>
            <seealso cref="M:Brecham.Obex.ObexClientSession.Put(System.String,System.String,System.Int64)"/>
        </member>
        <member name="M:Brecham.Obex.ObexPutStream.CloseCore(System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.ObexPutStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Overridden.  
            This method is not supported and always throws a 
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="M:Brecham.Obex.ObexPutStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes data to the <c>ObexPutStream</c>.
            </summary>
            <param name="buffer">An array of type <see cref="T:System.Byte"/> that 
            contains the data to write to the <see cref="T:Brecham.Obex.ObexPutStream"/>.</param>
            <param name="offset">The location in buffer from which to start writing data.</param>
            <param name="count">The number of bytes to write to the <c>ObexPutStream</c>.</param>
        </member>
        <member name="M:Brecham.Obex.ObexPutStream.Flush">
            <summary>
            Overridden. Clears all buffers for this stream and causes any buffered 
            data to be written to the peer.
            </summary>
            <remarks>
            The <see cref="T:Brecham.Obex.ObexPutStream"/> is buffered as it
            aims to make most efficient
            use of the network connection; it will only write maximum sized
            segments in normal operation.  The buffer will be emptied at 
            <see cref="M:Brecham.Obex.ObexPutStream.Close"/> or by calling this method.
            </remarks>
        </member>
        <member name="M:Brecham.Obex.ObexPutStream.putBodyPduSendRecv(System.Byte[])">
            <summary>
            Sends a Put_NonFinal PDU containing the given buffer as a Body
            header, and reads the response PDU.  If the response code is
            not 'Continue' then an exception is thrown, except that Windows' 
            Wireless Link sends 'Success' to even intermediate replies so we
            have to accept that too.
            </summary>
            <param name="data">The data to be sent as a Body part.  The 
            whole buffer is sent.</param>
        </member>
        <member name="P:Brecham.Obex.ObexPutStream.CanRead">
            <summary>
            Gets a value that indicates whether the <see cref="T:Brecham.Obex.ObexPutStream"/>
            supports reading. 
            This is always <c>false</c>.
            </summary>
        </member>
        <member name="P:Brecham.Obex.ObexPutStream.CanWrite">
            <summary>
            Gets a value that indicates whether the <see cref="T:Brecham.Obex.ObexPutStream"/>
            supports writing.  This is <c>true</c> if the stream is open.
            </summary>
        </member>
        <member name="T:Brecham.Obex.ObexGetStream">
            <summary>
            Provides the stream of content in a OBEX Get operation.
            </summary>
            <remarks>
            The <c>ObexGetStream</c> class provides methods for receiving data as part of
            a <c>Get</c> operation, see the links below.
            </remarks>
            <seealso cref="M:Brecham.Obex.ObexClientSession.Get(Brecham.Obex.ObexHeaderCollection)"/>
            <seealso cref="M:Brecham.Obex.ObexClientSession.Get(System.String,System.String)"/>
        </member>
        <member name="F:Brecham.Obex.ObexGetStream.ErrorMsgNeedNonnegativeNumber">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.ObexGetStream.CloseCore(System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.ObexGetStream.Flush">
            <summary>
            Flushes data from the stream. This method is reserved for future use.
            </summary>
            <remarks>
            The Flush method implements the <see cref="M:System.IO.Stream.Flush"/> method; 
            however, because <see cref="T:Brecham.Obex.ObexGetStream"/> do not support writing,
            it has no affect on this stream type. Calling the Flush method does not throw an exception.
            </remarks>
        </member>
        <member name="M:Brecham.Obex.ObexGetStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads data from the <c>ObexGetStream</c>.
            </summary>
            <param name="buffer">An array of type <see cref="T:System.Byte"/> that 
            is the location in memory to store data read from the <see cref="T:Brecham.Obex.ObexGetStream"/></param>
            <param name="offset">The location in buffer to begin storing the data to.</param>
            <param name="count">The number of bytes to read from the <c>ObexGetStream</c>.</param>
            <returns>The number of bytes read from the <c>ObexGetStream</c>.</returns>
        </member>
        <member name="M:Brecham.Obex.ObexGetStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Overridden.  
            
            This method is not supported and always throws a 
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:Brecham.Obex.ObexGetStream.CanRead">
            <summary>
            Gets a value that indicates whether the <see cref="T:Brecham.Obex.ObexPutStream"/>
            supports reading. 
            This is <c>true</c> if the stream is open.
            </summary>
        </member>
        <member name="P:Brecham.Obex.ObexGetStream.CanWrite">
            <summary>
            Gets a value that indicates whether the <see cref="T:Brecham.Obex.ObexPutStream"/>
            supports writing.
            This is always <c>false</c>.
            </summary>
        </member>
        <member name="P:Brecham.Obex.ObexGetStream.ResponseHeaders">
            <summary>
            Gets any headers returned by the server.
            </summary>
            <remarks>
            <para>
            Common headers include <see cref="F:Brecham.Obex.ObexHeaderId.Length"/>, 
            and <see cref="F:Brecham.Obex.ObexHeaderId.Time"/>.  The <c>Length</c> header
            being most useful, as it is necessary to allow progress reporting.  See for 
            instance the <c>FolderExplorer2</c> example which does byte-by-byte progress 
            reporting if that header is returned by the server, or bouncing bar pseudo 
            progress reporting if not.
            </para>
            <para>This property gives access to the collection of the aggregate metadata 
            headers received so far from the server, with any duplicate headers being 
            discarded.  Unfortunately the OBEX specification is not specific on 
            where response metadata headers should come in the GET process.  
            Generally &#x2014; and hopefully always &#x2014; the server will send all 
            of the metadata  headers before any content headers.
            Therefore 
            the stream constructor has been changed to return only once the first body
            header has been received.  This should guarantee that all the metadata headers
            have been received.
            </para>
            <para>&#xA0;</para>
            <para>
            As noted above,
            the specfication does not describe where in a possible multi-packet 
            exchange any headers should be returned; it only covers where the body headers
            are allowed: &#x201C;The server device must not begin sending the object body 
            chunks until the request phase is complete.&#x201D; OBEX13.pdf Section 3.3.4.
            </para><para>
            The general order is however:
            <list type="number">
            <item>Zero (but normally one) or more Request header(s) in one of more PDUs
            from the client.</item>
            <item>Zero or more Response metadata header(s) in zero or more PDUs.</item>
            <item>One of more content headers (Body/EndOfBody) in one or more PDUs.</item>
            </list>
            Often the the last response metadata headers will come in the PDU with the
            first content header, and often there will be only one PDU containing
            metadata header.  (If fact, for a small object, the response could be simply
            one PDU containing any metadata and a single content header).
            So, as noted above as long as the first content header has been received
            then the complete set of header should have arrived.
            </para>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.ObexGetStream.Length">
            <summary>
            Overridden. Gets the length of the data available on the stream.
            This property is not currently supported and always throws a 
            <see cref="T:System.NotSupportedException"/>.
            </summary>
            <remarks>
            The length of the object being downloaded is sometimes provided by the 
            server in its response headers, which can be accessed through the
            <see cref="P:Brecham.Obex.ObexGetStream.ResponseHeaders"/> property.  As noted there the header is
            <c>ObexHeaderId.</c><see cref="F:Brecham.Obex.ObexHeaderId.Length"/>.
            The contents of this header is not provided through this property as 
            there would be no good way to indicate that no header was included and 
            thus the length is unknown.
            </remarks>
        </member>
        <member name="T:Brecham.Obex.ObexHeaderCollection">
            <summary>
            Contains OBEX protocol headers associated with a request or response.
            </summary>
            <remarks>
            Like WebHeaderCollection, but for OBEX rather than HTTP.  
            OBEX headers have a one byte Header ID, and a value which is of one of
            four type: Unicode string, Byte sequence, a One byte value, and a
            four byte value.  The Header IDs includes the type as its top two 
            bits.  Thus the collection is type-strict; on adding or accessing the 
            collection it is an error if the value given does not match the type 
            specified by the header id.
            
            The collection only allows one header of each Header ID, and
            maintains order so that the order that the headers are present in the 
            PDU is maintained.
            
            As well as Add, Get, and the removal of entries, 
            the collection supports enumeration of the Header IDs.  
            It is safe to continue using the enumerator even if Remove has been 
            called meanwhile; all the IDs that were present at enumerator 
            creation will be returned by it.
            </remarks>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderCollection.ErrorMsgAddNotAnIntegerHeaderType">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderCollection.ErrorMsgAddNotAnArrayHeaderType">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderCollection.ErrorMsgAddNullByteArrayHeader">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderCollection.ErrorMsgAddNotAStringHeaderType">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderCollection.ErrorMsgAddNonByteForByteHeaderType">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderCollection.ErrorMsgExistsNot">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderCollection.ErrorMsgNotExistsDoes">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderCollection.ErrorMsgGetStringWrongHeaderType">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderCollection.ErrorMsgGetByteSeqWrongHeaderType">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderCollection.ErrorMsgGetOneByteWrongHeaderType">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderCollection.ErrorMsgGetFourByteWrongHeaderType">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderCollection.ErrorMsgAppendingToSelf">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.#ctor">
            <summary>
            Initialises a new instance empty of the <c>ObexHeaderCollection</c>.
            </summary>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.Clear">
            <summary>
            Removes all items from the collection.
            </summary>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.Remove(Brecham.Obex.ObexHeaderId)">
            <summary>
            Removes the specified header from the collection. 
            </summary>
            <param name="headerId">
            The <see cref="T:Brecham.Obex.ObexHeaderId"/>
            of the header to remove from the collection.
            </param>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.IsUnicodeType(Brecham.Obex.ObexHeaderId)">
            <summary>
            Gets whether the given Header ID represents a Unicode type.
            </summary>
            <param name="headerId">The <see cref="T:Brecham.Obex.ObexHeaderId"/> to check.</param>
            <returns>
            A <c>Boolean</c> value indicating whether the given header is of Unicode type.
            </returns>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.IsByteSeqType(Brecham.Obex.ObexHeaderId)">
            <summary>
            Gets whether the given Header ID represents a Byte Sequence type.
            </summary>
            <param name="headerId">The <see cref="T:Brecham.Obex.ObexHeaderId"/> to check.</param>
            <returns>
            A <c>Boolean</c> value indicating whether the given header is of Byte Sequence type.
            </returns>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.IsOneByteType(Brecham.Obex.ObexHeaderId)">
            <summary>
            Gets whether the given Header ID represents a One-byte type.
            </summary>
            <param name="headerId">The <see cref="T:Brecham.Obex.ObexHeaderId"/> to check.</param>
            <returns>
            A <c>Boolean</c> value indicating whether the given header is of One-byte type.
            </returns>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.IsFourByteType(Brecham.Obex.ObexHeaderId)">
            <summary>
            Gets whether the given Header ID represents a Four-byte type.
            </summary>
            <param name="headerId">The <see cref="T:Brecham.Obex.ObexHeaderId"/> to check.</param>
            <returns>
            A <c>Boolean</c> value indicating whether the given header is of Four-byte type.
            </returns>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.IsNumericType(Brecham.Obex.ObexHeaderId)">
            <summary>
            Gets whether the given Header ID represents a numeric type.
            </summary>
            <remarks>This is whether it is of One-byte or Four-byte type, which are generally
            use to hold numerical values.</remarks>
            <param name="headerId">The <see cref="T:Brecham.Obex.ObexHeaderId"/> to check.</param>
            <returns>
            A <c>Boolean</c> value indicating whether the given header is of numeric type.
            </returns>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.Contains(Brecham.Obex.ObexHeaderId)">
            <summary>
            Determines whether the collection contains a specific header.
            </summary>
            <param name="headerId">The <see cref="T:Brecham.Obex.ObexHeaderId"/>
            of the header to locate in the collection.</param>
            <returns></returns>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.Add(Brecham.Obex.ObexHeaderId,System.String)">
            <overloads>Adds a header to the collection.</overloads>
            ----
            <summary>
            Adds a header of type Unicode String to the collection.
            </summary>
            -
            <remarks>
            Note, when written to an OBEX PDU the Unicode String header is null-terminated, 
            thus if a <c>null</c> value is supplied here then an 'null' header will
            be written, that is three bytes {id,len1,len2}, 
            on the other hand if a zero length string is supplied then a corresponding
            header is written {id,len1,len2,0,0}.
            This matches the behaviour of 
            <see cref="M:Brecham.Obex.ObexHeaderCollection.GetString(Brecham.Obex.ObexHeaderId)"/>.
            </remarks>
            -
            <param name="headerId">The Header ID of the header to add.</param>
            <param name="value">
            A <see cref="T:System.String"/> value containing the content to add.
            </param>
            <exception cref="T:System.ArgumentException">
            The Header ID does not represent a Unicode String type.
            </exception>
            <exception cref="T:System.ArgumentException">
            A header of the given ID already exixts.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.Add(Brecham.Obex.ObexHeaderId,System.Byte[])">
            <summary>
            Adds a header of type Byte Sequence to the collection.
            </summary>
            <param name="headerId">The Header ID of the header to add.</param>
            <param name="value">
            A <see cref="T:System.Byte"/> Array value containing the content to add.
            </param>
            <exception cref="T:System.ArgumentException">
            The Header ID does not represent a Byte Sequence type.
            </exception>
            <exception cref="T:System.ArgumentException">
            A header of the given ID already exixts.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <c>value</c> is a null reference (<c>Nothing</c> in Visual Basic).
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.Add(Brecham.Obex.ObexHeaderId,System.Int32)">
            <summary>
            Adds a header of One-byte or Four-byte type to the collection. 
            </summary>
            <remarks>
            There are separate headers types for One-byte and Four-byte integral 
            values, equivalent to <c>Byte</c> and <c>Int32</c>/<c>UInt32</c> respectively.
            This overload will be called for <see cref="T:System.Int32"/> and
            <see cref="T:System.Byte"/> variables.  <see cref="T:System.UInt32"/>
            variables will call the other overload
            <see cref="M:Brecham.Obex.ObexHeaderCollection.Add(Brecham.Obex.ObexHeaderId,System.UInt32)"/>
            </remarks>
            <param name="headerId">The Header ID of the header to add.</param>
            <param name="value">
            A <see cref="T:System.Int32"/> value containing the content to add,
            this will also thus accept a <see cref="T:System.Byte"/> value.
            </param>
            <exception cref="T:System.ArgumentException">
            The Header ID does not represent an integral (One-byte/Four-byte) type.
            </exception>
            <exception cref="T:System.ArgumentException">
            A header of the given ID already exixts.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            A Header ID represent a One-Byte type, but the value is not a byte.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.Add(Brecham.Obex.ObexHeaderId,System.UInt32)">
            <summary>
            Adds a header of One-byte or Four-byte type to the collection. 
            </summary>
            <remarks>
            There are separate headers types for One-byte and Four-byte integral 
            values, equivalent to <c>Byte</c> and <c>Int32</c>/<c>UInt32</c> respectively.
            This overload will be called for <see cref="T:System.UInt32"/> variables.
            <see cref="T:System.Int32"/> and <see cref="T:System.Byte"/> 
            variables will call the other overload
            <see cref="M:Brecham.Obex.ObexHeaderCollection.Add(Brecham.Obex.ObexHeaderId,System.Int32)"/>
            </remarks>
            <param name="headerId">The Header ID of the header to add.</param>
            <param name="value">
            A <see cref="T:System.UInt32"/> value containing the content to add.
            </param>
            <exception cref="T:System.ArgumentException">
            The Header ID does not represent an integral (One-byte/Four-byte) type.
            </exception>
            <exception cref="T:System.ArgumentException">
            A header of the given ID already exixts.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            A Header ID represent a One-Byte type, but the value is not a byte.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.Prepend(Brecham.Obex.ObexHeaderId,System.Int32)">
            <overloads>Inserts a header of integral type to the front of the collection.</overloads>
            ----
            <summary>
            Insert a header of One-byte or Four-byte type at the front of the collection. 
            </summary>
            <remarks>
            There are separate headers types for One-byte and Four-byte integral 
            values, equivalent to <c>Byte</c> and <c>Int32</c>/<c>UInt32</c> respectively.
            This overload will be called for <see cref="T:System.UInt32"/> variables.
            <see cref="T:System.Int32"/> and <see cref="T:System.Byte"/> 
            variables will call the other overload
            <see cref="M:Brecham.Obex.ObexHeaderCollection.Prepend(Brecham.Obex.ObexHeaderId,System.UInt32)"/>
            </remarks>
            <param name="headerId">The Header ID of the header to add.</param>
            <param name="value">
            A <see cref="T:System.UInt32"/> value containing the content to add.
            </param>
            <exception cref="T:System.ArgumentException">
            The Header ID does not represent an integral (One-byte/Four-byte) type.
            </exception>
            <exception cref="T:System.ArgumentException">
            A header of the given ID already exixts.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            A Header ID represent a One-Byte type, but the value is not a byte.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.Prepend(Brecham.Obex.ObexHeaderId,System.UInt32)">
            <summary>
            Insert a header of One-byte or Four-byte type at the front of the collection. 
            </summary>
            <remarks>
            There are separate headers types for One-byte and Four-byte integral 
            values, equivalent to <c>Byte</c> and <c>Int32</c>/<c>UInt32</c> respectively.
            This overload will be called for <see cref="T:System.UInt32"/> variables.
            <see cref="T:System.Int32"/> and <see cref="T:System.Byte"/> 
            variables will call the other overload
            <see cref="M:Brecham.Obex.ObexHeaderCollection.Prepend(Brecham.Obex.ObexHeaderId,System.Int32)"/>
            </remarks>
            <param name="headerId">The Header ID of the header to add.</param>
            <param name="value">
            A <see cref="T:System.UInt32"/> value containing the content to add.
            </param>
            <exception cref="T:System.ArgumentException">
            The Header ID does not represent an integral (One-byte/Four-byte) type.
            </exception>
            <exception cref="T:System.ArgumentException">
            A header of the given ID already exixts.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            A Header ID represent a One-Byte type, but the value is not a byte.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.AddType(System.String)">
            <summary>
            Add a Type header, converting the string value to the correct format for the Type header.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.AppendSkippingAnyDuplicates(Brecham.Obex.ObexHeaderCollection)">
            <summary>
            Copies the headers in the specified <c>ObexHeaderCollection</c> to the
            current <c>ObexHeaderCollection</c>.
            </summary>
            <remarks>
            If a header in <c>headers</c> already exists in the target 
            <c>ObexHeaderCollection</c>, then it is not copied and remains in the 
            source collection.  Otherwise it is added to the end of the target 
            collection and removed from the source.  Thus, on completion the source
            collection contains only the headers that were duplicates.
            </remarks>
            <param name="headers">
            The <see cref="T:Brecham.Obex.ObexHeaderCollection"/> to copy to the 
            current <c>ObexHeaderCollection</c>.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <c>headers</c> is a null reference (<c>Nothing</c> in Visual Basic).
            </exception>
            <exception cref="T:System.ArgumentException">
            <c>headers</c> is a reference to the current collection.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.GetString(Brecham.Obex.ObexHeaderId)">
            <overloads>
            Gets the value of the header in the collection with the given header id.
            </overloads>
            ----
            <summary>
            Gets the value of the Unicode String 
            header in the collection with the given header id.
            </summary>
            -
            <remarks>
            <para>The encoded form of a string header contains null-termination thus 
            there are two forms of &#x2018;empty&#x2019;, that is: with null-termination
            and without.
            We return <see langword="null"/> if the header was zero-length (a total 
            header length of three-bytes), and return "" if the header contained 
            null-termination bytes (a total header length of five).
            This matches the behaviour of 
            <see cref="M:Brecham.Obex.ObexHeaderCollection.Add(Brecham.Obex.ObexHeaderId,System.String)"/>.
            </para>
            </remarks>
            -
            <param name="headerId">
            The <see cref="T:Brecham.Obex.ObexHeaderId"/> of the header to get.  
            This must be a header id of type Unicode String, otherwise an error will occur.
            </param>
            -
            <returns>
            A <see cref="T:System.String"/> holding the value of the specified header.
            </returns>
            -
            <exception cref="T:System.ArgumentException">
            The specified Header ID is not of Unicode String type.
            </exception>
            <exception cref="T:System.ArgumentException">
            No header with specified Header Id is present in the collection.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.GetByteSeq(Brecham.Obex.ObexHeaderId)">
            <summary>
            Gets the value of the Byte Sequence
            header in the collection with the given header id.
            </summary>
            <param name="headerId">
            The <see cref="T:Brecham.Obex.ObexHeaderId"/> of the header to get.  
            This must be a header id of type Byte Sequence, otherwise an error will occur.
            </param>
            <returns>
            A <see cref="T:System.Byte"/> array holding the value of the specified header.
            </returns>
            <exception cref="T:System.ArgumentException">
            The specified Header ID is not of Byte Sequence type.
            </exception>
            <exception cref="T:System.ArgumentException">
            No header with specified Header Id is present in the collection.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.GetOneByte(Brecham.Obex.ObexHeaderId)">
            <summary>
            Gets the value of the One-byte
            header in the collection with the given header id.
            </summary>
            <param name="headerId">
            The <see cref="T:Brecham.Obex.ObexHeaderId"/> of the header to get.  
            This must be a header id of type One-byte, otherwise an error will occur.
            </param>
            <returns>
            A <see cref="T:System.Byte"/> holding the value of the specified header.
            </returns>
            <exception cref="T:System.ArgumentException">
            The specified Header ID is not of One-byte type.
            </exception>
            <exception cref="T:System.ArgumentException">
            No header with specified Header Id is present in the collection.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.GetFourByteAsSigned(Brecham.Obex.ObexHeaderId)">
            <summary>
            Gets the value of the Four-byte
            header in the collection with the given header id,
            as a signed value.
            </summary>
            <param name="headerId">
            The <see cref="T:Brecham.Obex.ObexHeaderId"/> of the header to get.  
            This must be a header id of type Four-byte, otherwise an error will occur.
            </param>
            <returns>
            A <see cref="T:System.Int32"/> holding the value of the specified header.
            The companion function <see cref="M:Brecham.Obex.ObexHeaderCollection.GetFourByteAsUnsigned(Brecham.Obex.ObexHeaderId)"/>
            return the value as an <c>UInt32</c>.
            </returns>
            <exception cref="T:System.ArgumentException">
            The specified Header ID is not of One-Byte type.
            </exception>
            <exception cref="T:System.ArgumentException">
            No header with specified Header Id is present in the collection.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.GetFourByteAsUnsigned(Brecham.Obex.ObexHeaderId)">
            <summary>
            Gets the value of the Four-byte
            header in the collection with the given header id,
            as an unsigned value.
            </summary>
            <param name="headerId">
            The <see cref="T:Brecham.Obex.ObexHeaderId"/> of the header to get.  
            This must be a header id of type Four-byte, otherwise an error will occur.
            </param>
            <returns>
            A <see cref="T:System.UInt32"/> holding the value of the specified header.
            The companion function <see cref="M:Brecham.Obex.ObexHeaderCollection.GetFourByteAsSigned(Brecham.Obex.ObexHeaderId)"/>
            return the value as an <c>Int32</c>.
            </returns>
            <exception cref="T:System.ArgumentException">
            The specified Header ID is not of One-Byte type.
            </exception>
            <exception cref="T:System.ArgumentException">
            No header with specified Header Id is present in the collection.
            </exception>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <remarks>
            The enumeration is of the Header ID keys.  
            As noted in the class documentation, 
            it is safe to continue using the enumerator even if 
            <see cref="M:Brecham.Obex.ObexHeaderCollection.Remove(Brecham.Obex.ObexHeaderId)"/> has been 
            called meanwhile; at all times all the IDs that were present when the
            enumerator was created will be returned by it.
            </remarks>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerator`1"/> 
            that can be used to iterate through the collection, returning the 
            <see cref="T:Brecham.Obex.ObexHeaderId"/> keys.
            </returns>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <remarks>
            The enumeration is of the Header ID keys.  
            As noted in the class documentation, 
            it is safe to continue using the enumerator even if 
            <see cref="M:Brecham.Obex.ObexHeaderCollection.Remove(Brecham.Obex.ObexHeaderId)"/> has been 
            called meanwhile; at all times all the IDs that were present when the
            enumerator was created will be returned by it.
            </remarks>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerator`1"/> 
            that can be used to iterate through the collection, returning the 
            <see cref="T:Brecham.Obex.ObexHeaderId"/> keys..
            </returns>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderCollection.Dump(System.IO.TextWriter)">
            <summary>
            Create a diagnostic 'dump' of the contents of the header collection.
            </summary>
            <param name="writer">
            A <see cref="T:System.IO.TextWriter"/> to which the dump will be written,
            this could for instance be <see cref="P:System.Console.Out">Console.Out</see>, or an
            instance of <see cref="T:System.IO.StringWriter"/>.
            </param>
        </member>
        <member name="P:Brecham.Obex.ObexHeaderCollection.Count">
            <summary>
            Gets the number of elements contained in the collection.
            </summary>
        </member>
        <member name="P:Brecham.Obex.ObexHeaderCollection.Keys">
            <summary>
            Gets the collection of <see cref="T:Brecham.Obex.ObexHeaderId"/>s 
            in the collection.
            </summary>
        </member>
        <member name="T:Brecham.Obex.ObexHeaderConverter">
            <summary>
            Methods to convert types into the formats required by various OBEX header types.
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderConverter.Iso8601Format">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderConverter.StringAsAsciiByteSeq(System.String,System.Boolean)">
            <summary>
            Converts a <see cref="T:System.String"/> into a 
            <see cref="T:System.Byte"/> array containing ASCII encoded text, 
            to be carried in a byte sequence header type.
            </summary>
            <remarks>
            The conversion is a strict conversion where the platform supports 
            <c>EncoderFallback</c>, i.e. not on CF or FXv1.1.
            </remarks>
            <exception cref="T:System.Text.EncoderFallbackException">
            The given string is not in ASCII format.
            </exception>
            <param name="value">The <see cref="T:System.String"/> to be converted.</param>
            <param name="nullTerminate">Whether to add a null terminator byte to 
            the byte array.  The Type header has null-termination, but the Time header
            has not, for instance.</param>
            <returns>A <see cref="T:System.Byte"/> array in the requested format.</returns>
            <seealso cref="M:Brecham.Obex.ObexHeaderConvertor.StringFromAsciiByteSeq"/>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderConverter.StringFromAsciiByteSeq(System.Byte[])">
            <overloads>
            Converts a <see cref="T:System.Byte"/> array containing ASCII encoded text, 
            as carried in a byte sequence header type, back into a <see cref="T:System.String"/>.
            </overloads>
            --
            <summary>
            Converts a <see cref="T:System.Byte"/> array containing ASCII encoded text, 
            as carried in a byte sequence header type, back into a <see cref="T:System.String"/>.
            </summary>
            <remarks>
            The conversion is a strict conversion where the platform supports 
            <c>DecoderFallback</c>, i.e. not on CF or FXv1.1.
            </remarks>
            <exception cref="T:System.Text.EncoderFallbackException">
            The content of the given byte sequence is not in ASCII format.
            </exception>
            <param name="bytes">The received <see cref="T:System.Byte"/> array.</param>
            <returns>The <see cref="T:System.String"/> result.</returns>
            <seealso cref="M:Brecham.Obex.ObexHeaderConvertor.StringAsAsciiByteSeq"/>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderConverter.StringFromAsciiByteSeq(System.Byte[],System.Boolean@)">
            <summary>
            Converts a <see cref="T:System.Byte"/> array containing ASCII encoded text, 
            as carried in a byte sequence header type, back into a <see cref="T:System.String"/>.
            Also returning whether the supplied value was null-terminated.
            </summary>
            <remarks>
            The conversion is a strict conversion where the platform supports 
            <c>DecoderFallback</c>, i.e. not on CF or FXv1.1.
            </remarks>
            <exception cref="T:System.Text.EncoderFallbackException">
            The content of the given byte sequence is not in ASCII format.
            </exception>
            <param name="bytes">The received <see cref="T:System.Byte"/> array.</param>
            <param name="wasNullTerminated">On return, whether the ASCII encoded 
            string in the <see cref="T:System.Byte"/> array was null-terminated.</param>
            <returns>The <see cref="T:System.String"/> result.</returns>
            <seealso cref="M:Brecham.Obex.ObexHeaderConvertor.StringAsAsciiByteSeq"/>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderConverter.DateTimeAsIso8601ByteSeq(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> into 
            a <see cref="T:System.Byte"/> array containing ASCII encoded text, 
            to be carried in a Byte Sequence Header type.
            </summary>
            <remarks>
            <para>
            This is the conversion as described in OBEX13.pdf Section 2.2.5, regarding
            the format for the “Time” header.  This creates as ASCII 
            string with the date and time formatted in ISO 8601 style as 
            YYYYMMDDTHHDDMMSS, with a final letter Z if the date and time are in UTC.
            It is not specified there, but we can see from the example in section 
            9.2.4 that the string should not be null-terminated.
            </para><para>
            <c>DateTime</c> has three defined ‘kinds’ 
            (<see cref="T:System.DateTimeKind"/>): <c>Unspecified</c>, <c>Utc</c>, 
            and <c>Local</c>.  We
            mark the time as UTC only if the <c>DateTime</c> passed is of 
            ‘kind’ <c>Utc</c>.
            This of course applies only to framework version 2 and later.
            </para>
            </remarks>
            <param name="value">The <see cref="T:System.DateTime"/> to be converted.</param>
            <returns>A <see cref="T:System.Byte"/> array containing the date and time 
            value in the defined format.</returns>
            <seealso cref="M:Brecham.Obex.ObexHeaderConverter.DateTimeFromIso8601ByteSeq(System.Byte[])"/>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderConverter.DateTimeAsIso8601String(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> into 
            a <see cref="T:System.String"/> in the format that can be ASCII encoded
            to be carried in a Byte Sequence Header type.
            </summary>
            -
            <remarks>
            <para>See <see cref="M:Brecham.Obex.ObexHeaderConverter.DateTimeAsIso8601ByteSeq(System.DateTime)"/>
            for information on this conversion.
            </para>
            </remarks>
            -
            <param name="value">The <see cref="T:System.DateTime"/> to be converted.</param>
            -
            <returns>A <see cref="T:System.String"/> containing the date and time 
            value in the defined format.</returns>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderConverter.DateTimeFromIso8601ByteSeq(System.Byte[])">
            <summary>
            Converts a <see cref="T:System.Byte"/> array containing ASCII encoded text,
            containing a date/time value formatted in ISO8601 style into a 
            <see cref="T:System.DateTime"/> instance.
            </summary>
            <remarks>
            <para>
            As discussed in the corresponding conversion method
            <see cref="M:Brecham.Obex.ObexHeaderConverter.DateTimeAsIso8601ByteSeq(System.DateTime)"/>
            the date time is formatted in text as YYYYMMDDTHHDDMMSS, with a final 
            letter Z if the date and time are in UTC.
            </para><para>
            <c>DateTime</c> has three defined ‘kinds’ 
            (<see cref="T:System.DateTimeKind"/>): <c>Unspecified</c>, <c>Utc</c>, 
            and <c>Local</c>.  
            Depending on whether the input is marked as UTC we
            mark the <c>DateTime</c> returned as <c>Utc</c>, and <c>Local</c> respectively.
            This of course applies only to framework version 2 and later.
            </para><para>
            Note, we allow the string to have a final null-termination byte.
            </para>
            </remarks>
            <param name="bytes">The received <see cref="T:System.Byte"/> array containing 
            the formatted Time string.</param>
            -
            <returns>A <see cref="T:System.DateTime"/> representing the encoded date/time.
            </returns>
            -
            <seealso cref="M:Brecham.Obex.ObexHeaderConverter.DateTimeAsIso8601ByteSeq(System.DateTime)"/>
        </member>
        <member name="M:Brecham.Obex.ObexHeaderConverter.DateTimeFromIso8601String(System.String)">
            <summary>
            Converts a <see cref="T:System.String"/> 
            containing a date/time value formatted in ISO8601 style into a 
            <see cref="T:System.DateTime"/> instance.
            </summary>
            -
            <remarks>
            <para>See <see cref="M:Brecham.Obex.ObexHeaderConverter.DateTimeFromIso8601ByteSeq(System.Byte[])"/>
            for information on this conversion.
            </para>
            </remarks>
            -
            <param name="value">The received <see cref="T:System.String"/> containing 
            the formatted Time string.</param>
            -
            <returns>A <see cref="T:System.DateTime"/> representing the encoded date/time.
            </returns>
        </member>
        <member name="T:Brecham.Obex.ObexHeaderId">
            <summary>
            OBEX Header Identifiers.
            </summary>
            <remarks>
            Defined in OBEX13.pdf, section 2.1.  Quoted text below is from there.
            </remarks>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.Count">
            <summary>
            &#x201C;Number of objects (used by Connect)&#x201D;
            <c>[four byte]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.Name">
            <summary>
            &#x201C;name of the object (often a file name)&#x201D;
            <c>[Unicode text]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.Type">
            <summary>
            &#x201C;type of object - e.g. text, html, binary, manufacturer specific&#x201D;
            <c>[byte sequence &#x2014; consisting of null terminated ASCII text]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.Length">
            <summary>
            &#x201C;the length of the object in bytes&#x201D;
            <c>[four byte]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.Time">
            <summary>
            &#x201C;date/time stamp – ISO 8601 version - preferred&#x201D;
            <c>[byte sequence &#x2014; encoded as a US-ASCII string]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.TimeOldFourByte">
            <summary>
            &#x201C;date/time stamp – 4 byte version (for compatibility only)&#x201D;
            <c>[four byte]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.Description">
            <summary>
            &#x201C;text description of the object&#x201D;
            <c>[Unicode text]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.Target">
            <summary>
            &#x201C;name of service that operation is targeted to&#x201D;
            <c>[byte sequence]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.Http">
            <summary>
            &#x201C;an HTTP 1.x header&#x201D;
            <c>[byte sequence]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.Body">
            <summary>
            &#x201C;a chunk of the object body.&#x201D;
            <c>[byte sequence]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.EndOfBody">
            <summary>
            &#x201C;the final chunk of the object body&#x201D;
            <c>[byte sequence]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.Who">
            <summary>
            &#x201C;identifies the OBEX application	used to tell if talking to a peer&#x201D;
            <c>[byte sequence]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.ConnectionId">
            <summary>
            &#x201C;an identifier used for OBEX connection multiplexing&#x201D;
            <c>[four byte]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.AppParameters">
            <summary>
            &#x201C;extended application request &amp; response information&#x201D;
            <c>[byte sequence]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.AuthChallenge">
            <summary>
            &#x201C;authentication digest-challenge&#x201D;
            <c>[byte sequence]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.AuthResponse">
            <summary>
            &#x201C;authentication digest-response&#x201D;
            <c>[byte sequence]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.CreatorId">
            <summary>
            &#x201C;indicates the creator of an object&#x201D;
            <c>[four byte]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.WanUuid">
            <summary>
            &#x201C;uniquely identifies the network client (OBEX server)&#x201D;
            <c>[byte sequence]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.ObjectClass">
            <summary>
            &#x201C;OBEX Object class of object&#x201D;
            <c>[byte sequence]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.SessionParameters">
            <summary>
            &#x201C;Parameters used in session commands/responses&#x201D;
            <c>[byte sequence]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.SessionSequenceNumber">
            <summary>
            &#x201C;Sequence number used in each OBEX packet for reliability&#x201D;
            <c>[one byte]</c>
            </summary>
        </member>
        <member name="F:Brecham.Obex.ObexHeaderId.ProxyPreHeadersBytes">
            <summary>
            A locally-defined header, to hold the special bytes carried in the 
            Connect request and response, and SetPath request PDUs.
            <c>[byte sequence]</c>
            </summary>
        </member>
        <member name="T:Brecham.Obex.Pdus.ObexHeaderIdMasks">
            <summary>
            Mask values to us with the enum ObexHeaderId.
            </summary>
            <remarks>
            Mask values to us with the enum ObexHeaderId.  The header value encodes
            which type it is in the top two bits, so one can use code like the following.
            <code lang="C#">
            ObexHeaderId headerId = ...;
            bool isStringType = (headerId &amp; ObexHeaderIdMasks.MaskType) == ObexHeaderIdMasks.TypeString;
            </code>
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexHeaderIdMasks.MaskType">
            <summary>
            Mask to mask off the 'type' bits of the value.  See the example in the 
            class page (<see cref="T:Brecham.Obex.Pdus.ObexHeaderIdMasks"/>).
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexHeaderIdMasks.TypeString">
            <summary>
            Unicode UTF-16BE
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexHeaderIdMasks.TypeByteSeq">
            <summary>
            Byte array
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexHeaderIdMasks.TypeOneByte">
            <summary>
            Byte, no length
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexHeaderIdMasks.TypeFourByte">
            <summary>
            Int32
            </summary>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexHeaderIdMasks.GetName(Brecham.Obex.ObexHeaderId)">
            <summary>
            Retrieves the name of the type mask that has the specified value.
            </summary>
            <param name="mask">
            A <see cref="T:Brecham.Obex.ObexHeaderId"/> holding the type mask value.
            </param>
            <returns>
            A string containing the name of the type mask whose value is <paramref name="mask"/>,
            or a null reference (Nothing in Visual Basic) if no such constant is found.
            </returns>
            <seealso cref="M:Brecham.Obex.Pdus.ObexHeaderIdMasks.GetNameFromHeaderId(Brecham.Obex.ObexHeaderId)"/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexHeaderIdMasks.GetNameFromHeaderId(Brecham.Obex.ObexHeaderId)">
            <summary>
            Retrieves the name of the type for the specified header id.
            </summary>
            <param name="headerId">
            A <see cref="T:Brecham.Obex.ObexHeaderId"/> holding the type mask value.
            </param>
            <returns>
            A string containing the name of the type mask for the specified header id value.
            </returns>
            <seealso cref="M:Brecham.Obex.Pdus.ObexHeaderIdMasks.GetName(Brecham.Obex.ObexHeaderId)"/>
        </member>
        <member name="T:Brecham.Obex.Pdus.ObexOpcode">
            <summary>
            OBEX Request PDU opcodes.
            </summary>
            <remarks>
            Defined in OBEX13.pdf, section 3.3.  Quoted text below is from there.
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexOpcode.Connect">
            <summary>
            &#x201C;choose your partner, negotiate capabilities&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexOpcode.Disconnect">
            <summary>
            &#x201C;signal the end of the session&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexOpcode.Put">
            <summary>
            &#x201C;send an object&#x201D;, final segment
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexOpcode.PutNonFinal">
            <summary>
            &#x201C;send an object&#x201D;, non-final segment
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexOpcode.Get">
            <summary>
            &#x201C;get an object&#x201D;, final segment
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexOpcode.GetNonFinal">
            <summary>
            &#x201C;get an object&#x201D;, non-final segment
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexOpcode.SetPath">
            <summary>
            &#x201C;modifies the current path on the receiving side&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexOpcode.Session">
            <summary>
            &#x201C;used for reliable session support&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexOpcode.Abort">
            <summary>
            &#x201C;abort the current operation&#x201D;
            </summary>
        </member>
        <member name="T:Brecham.Obex.Pdus.ObexOpcodeMasks">
            <summary>
            Mask values to use with the enum ObexOpcode.
            </summary>
            <remarks>
            Mask values to use with the enum ObexOpcode.  The Opcode value encodes in 
            the top bit whether it is 'Final' or not, so one can use code like the following.
            <code lang="C#">
            ObexOpcode opcode = ...;
            bool isFinal = (reqPdu.Opcode &amp; ObexOpcodeMasks.FinalBit) != 0;
            </code>
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexOpcodeMasks.FinalBit">
            <summary>
            Mask out the 'Final' bit alone.  See an example in the class page
            (<see cref="T:Brecham.Obex.Pdus.ObexOpcodeMasks"/>).
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexOpcodeMasks.MaskNonFinal">
            <summary>
            Mask off the 'Final' bit, leaving only the numerical bits as a non-Final value.
            </summary>
        </member>
        <member name="T:Brecham.Obex.Pdus.ObexResponseCode">
            <summary>
            OBEX Response PDU codes.
            </summary>
            <remarks>
            Defined in OBEX13.pdf, section 3.2.1.  Quoted text below is from there.
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.Continue">
            <summary>
            &#x201C;Continue&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.Success">
            <summary>
            &#x201C;OK, Success&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.BadRequest">
            <summary>
            &#x201C;Bad Request - server couldn’t understand request&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.Unauthorized">
            <summary>
            &#x201C;Unauthorized&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.Forbidden">
            <summary>
            &#x201C;Forbidden - operation is understood but refused&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.NotFound">
            <summary>
            &#x201C;Not Found&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.MethodNotAllowed">
            <summary>
            &#x201C;Method not allowed&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.NotAcceptable">
            <summary>
            &#x201C;Not Acceptable&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.Conflict">
            <summary>
            &#x201C;Conflict&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.EntityTooLarge">
            <summary>
            &#x201C;Requested entity too large&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.InternalServerError">
            <summary>
            &#x201C;Internal Server Error&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.NotImplemented">
            <summary>
            &#x201C;Not Implemented&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.ServiceUnavailable">
            <summary>
            &#x201C;Service Unavailable&#x201D;
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexResponseCode.PeerUnsupportedService">
            <summary>
            Locally defined, indicates that the peer didn't confirm support for 
            the requested service in its Connect response.
            </summary>
        </member>
        <member name="T:Brecham.Obex.Pdus.ObexPduType">
            <summary>
            Locally defined, indicates what PDU type is being passed, this is 
            required for 
            <see cref="T:Brecham.Obex.Pdus.ObexPduFactory"/><c>.</c><see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Parse(Brecham.Obex.Pdus.ObexPduType,System.Byte[],System.Int32)"/>
            so that it knows what form of PDU it is to handle, 
            and thus whether it contains extra 
            pre-headers bytes&#x2014;as Connect PDUs do, for instance.
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduType.Request">
            <summary>
            A Request PDU (of unspecified type; Connect or not etc).
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduType.Response">
            <summary>
            A normal Response PDU, i.e. not a Connect response PDU.
            </summary>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduType.ResponseToConnect">
            <summary>
            A Connect Response PDU.
            </summary>
        </member>
        <member name="T:Brecham.Obex.Pdus.ObexPduFactory">
            <summary>
            Creates and parses OBEX PDUs, is used internally by <c>ObexClientSession</c> 
            etc.
            </summary>
            <preliminary/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.OpcodeAndIdLen">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.LengthFieldLen">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.HeaderHeaderLen">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.MinimumPduLength">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.MinimumMru">
            <summary>
            The minimum recommended PDU maximum size (maximum receive unit),
            has value 255.  
            </summary>
            <remarks>
            <para>See OBEX13.pdf section 3.3.1.4.</para>
            <para>Even though the specification says that
            &#x201C;This value is the minimum acceptable value for the OBEX Maximum 
            Packet Length parameter exchanged in the CONNECT Operation.&#x201D; we 
            do not enforce this strictly
            as we know that some devices do use a smaller buffer size, 
            we do write a Trace warning.</para>
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.MaximumMru">
            <summary>
            The maximum PDU size (maximum receive unit), has value 65535, i.e. 
            <c>UInt16.</c><see cref="F:System.UInt16.MaxValue"/>.
            </summary>
            <remarks>
            From OBEX13.pdf section 3.1, 
            &#x201C;The maximum packet length is 64K bytes - 1.&#x201D;
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.DefaultMru">
            <summary>
            The default maximum PDU size (maximum receive unit), has value 255.
            </summary>
            <remarks>
            <para>See OBEX13.pdf section 3.3.1.3.</para>
            <para>At Connect time the peers each send their 
            &#x201C;maximum OBEX packet length&#x201D;, 
            and each will thereafter use the value received as their maximum send size.
            </para>
            <para>To restrict the maximum size packet we will *send* use the 
            <see cref="P:Brecham.Obex.Pdus.ObexPduFactory.Mtu"/> property.
            </para>
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgResponseCodeMustFinal">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgGivenRequestCodeMustFinal">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgArgumentInvalidOffLen">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgPeerBadVersion">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgConnectBytesParsedWrongLength">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgMruOutOfRange">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.TraceMsgFormatMruSmallerThan255">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.TraceMsgMruSmallerThan255IsZero">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.TraceMsgFormatMtuSmallerThan255">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.TraceMsgErrorConnectResponseBadNormalFormat">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgCreateBufferSmallerThanMinimum">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgCreateOverrun">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgBodyStreamAndHeaders">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgParseInputTooShort">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgPrefixParsePduOverrun">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgFormatParsePduOverrun">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgParsePduOverrunLocationPrefix">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgParseStringNotNullT">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgParseStringOddLength">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Pdus.ObexPduFactory.ErrorMsgHeaderLengthFieldIllegalValue">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.#ctor(System.Int32)">
            <summary>
            Initialise a new instance of the <c>ObexPduFactory</c> class, with a local
            receive buffer size as specified.  This instance can then be used to 
            create and parse OBEX PDUs exchanged with an OBEX peer device.
            </summary>
            -
            <remarks>
            <para>
            <paramref name="bufferSize"/> sets size of our local receive buffer, which is 
            as the <see cref="P:Brecham.Obex.Pdus.ObexPduFactory.LocalMru"/> 
            property.  This size will be advertised to the peer as our 
            &#x201C;maximum OBEX packet length&#x201D;
            in the CONNECT PDU if one is sent.
            </para>
            <para>
            See <see cref="F:Brecham.Obex.Pdus.ObexPduFactory.MinimumMru"/> and
            <see cref="F:Brecham.Obex.Pdus.ObexPduFactory.MaximumMru"/> for size 
            restrictions
            </para>
            </remarks>
            -
            <param name="bufferSize">The size of our local receive buffer.</param>
            -
            <exception cref="T:System.ArgumentException">
            <paramref name="bufferSize"/> is not in the valid range.
            </exception>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.CheckMru(System.Int32)">
            <exclude/>
            <remarks>
            <para>
            See <see cref="F:Brecham.Obex.Pdus.ObexPduFactory.MinimumMru"/> and
            <see cref="F:Brecham.Obex.Pdus.ObexPduFactory.MaximumMru"/> for size 
            restrictions
            </para>
            </remarks>
            -
            <exception cref="T:System.ArgumentException">
            <paramref name="mru"/> is not in the valid range.
            </exception>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.SetLocalMruNoCheck(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.SetPeerMruNoCheck(System.Int32)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.ClearMtu">
            <summary>
            Reset the local Maximum Transmission Unit, that is our maximum send size.
            This removes any value set earlier by the 
            <see cref="P:Brecham.Obex.Pdus.ObexPduFactory.Mtu"/> property
            and thus removes the local restriction on the maximum size of PDUs we will send.
            </summary>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.GetReceiveBuffer">
            <summary>
            Get a buffer of the correct size for receiving.
            </summary>
            <remarks>
            <note>
            This will likely change in a later version to to same pattern as for the 
            send buffer, ie <c>GetNewReceiveBuffer</c>/<c>GetReceiveBuffer</c>.
            </note>
            This method allocates a new byte array of size
            <see cref="P:Brecham.Obex.Pdus.ObexPduFactory.LocalMru"/> 
            on each call.
            On the send side we aim to use only a single buffer for efficiency, 
            hence the 
            <see cref="M:Brecham.Obex.Pdus.ObexPduFactory.GetNewSendBuffer"/> and
            <see cref="M:Brecham.Obex.Pdus.ObexPduFactory.GetSendBuffer"/>
            methods. On the receive side it is expected that a single buffer be allocated
            to receive the first PDU and it is used to receive each subsequent PDUs into.
            As OBEX only
            allows one command to be outstanding at one time this is acceptable.  If
            also receiving a PDU before the previous response is sent &#x2014; to 
            handle early 
            ABORT &#x2014;
            then a separate buffer will have to be used then however.
            </remarks>
            <returns>A Byte array of the maximum size of PDU allowed to be received 
            from the peer.
            </returns>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.GetNewSendBuffer">
            <summary>
            Allocates a new buffer of the correct size for sending.
            </summary>
            <returns>A Byte array of the maximum size of PDU allowed to be sent to the
            peer, that is the minimum of size 
            <see cref="P:Brecham.Obex.Pdus.ObexPduFactory.PeerMru"/> and
            <see cref="P:Brecham.Obex.Pdus.ObexPduFactory.Mtu"/>.
            This is new buffer, unlike 
            <see cref="M:Brecham.Obex.Pdus.ObexPduFactory.GetSendBuffer"/>
            which returns the single shared buffer.
            </returns>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.GetSendBuffer">
            <summary>
            Get a buffer of the correct size for sending.  In this implementation one
            buffer is used for *all* sends for efficiency.
            </summary>
            <remarks>
            <para>
            Get a buffer of the correct size for sending.  In this implementation one
            buffer is for all sends for effieciency.
            </para><para>
            Using a single buffer is suitable
            because OBEX only allow one command to be outstanding at any time, so the 
            response to one command must be received before sending the next. There is 
            one exception to this; the ABORT command can be sent without waiting for 
            the previous response.  In that case a new buffer should be allocated with
            <see cref="M:Brecham.Obex.Pdus.ObexPduFactory.GetNewSendBuffer"/> and 
            passed to a <c>CreateRequest</c> overload that take the buffer in a byte 
            array parameter.
            </para>
            </remarks>
            <returns>A Byte array of the maximum size of PDU allowed to be sent to the
            peer.  Note this is a shared buffer as discussed above.
            </returns>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.CheckRequestCode(System.Byte[])">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.CheckResponseCode(System.Byte[])">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.GetPreHeadersParseLength(Brecham.Obex.Pdus.ObexPduType,System.Byte)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.UseConnectBytes(System.Byte[])">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.MakeConnectBytes">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.AddConnectBytes(Brecham.Obex.ObexHeaderCollection@)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(Brecham.Obex.Pdus.ObexOpcode)">
            <summary>
            Overloaded <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>
            with <c>headers</c>, and <c>bodyStream</c> defaulted to null
            </summary>
            <param name="opcode">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <returns>See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </returns>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection)">
            <summary>
            Overloaded <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>
            with <c>bodyStream</c> defaulted to null
            </summary>
            <param name="opcode">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <param name="headers">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <returns>See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </returns>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)">
            <summary>
            Overloaded <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(System.Byte[],Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>
            but using the shared buffer as returned by <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.GetSendBuffer"/>
            </summary>
            <param name="opcode">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(System.Byte[],Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <param name="headers">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(System.Byte[],Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <param name="bodyStream">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(System.Byte[],Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <returns>See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(System.Byte[],Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </returns>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.CreateRequest(System.Byte[],Brecham.Obex.Pdus.ObexOpcode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)">
            <overloads>
            Create a request PDU, 
            and validity checks the resultant PDU.
            </overloads>
            ----
            <summary>
            Create a request PDU, 
            and validity checks the resultant PDU.
            </summary>
            -
            <remarks>
            <para>
            The response code specified can be any valid code; 
            either Final (the &#x2018;final&#x2019; bit set), or non-Final if the 
            code is valid as non-final, but see below.
            </para>
            <para>
            If creating a Connect PDU the extra Connect bytes will be added,
            they define the protocol version in use and the maximum packet size.
            The latter is as set at initialisation with <c>bufferSize</c>, or 
            subsequently with
            <see cref="P:Brecham.Obex.Pdus.ObexPduFactory.LocalMru"/>.
            </para>
            <para>
            If the all headers do no fit within the maximum 
            PDU size then as with <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/> 
            any unincluded headers remain if the <c>header</c> collection.  In that 
            case we also assume that the remaining headers will be sent in the folowing
            PDU and thus we clear the final bit in the opcode.  That also is done
            if a body header type was added with content from the <c>bodyStream</c>.
            </para>
            <para>
            The PDU and its opcode are then checked for validity.
            Only certain opcodes can be non-final ie PUT and GET. CONNECT for instance
            cannot.  See OBEX13.pdf sections 3.3 and 3.1.
            If the opcode is invalid then <see cref="T:System.Net.ProtocolViolationException"/> 
            is thrown.
            </para>
            <para>
            If sending a PDU that cannot have its headers split across PDUs then 
            the caller should handle that case externally, as it can know what to 
            do in that case.  For instance when sending an Abort or Disconnect, 
            <c>ObexClientSession</c> will at first attempt to include the <c>reason</c>
            text string but if that fails then it tries again but without the string
            header.  There are thus two exceptions that can occur on the headers
            being too long: <c>ProtocolViolationException</c> as described here,
            and <c>ObexCreateTooLongException</c> is even the first header
            would not fit, see <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            aaaa <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </para>
            </remarks>
            --
            <param name="buffer">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <param name="opcode">
            The opcode to include in the PDU,
            as an <see cref="T:Brecham.Obex.Pdus.ObexOpcode"/>.
            </param>
            <param name="headers">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <param name="bodyStream">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            -
            <returns>See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </returns>
            -
            <exception cref="T:System.Net.ProtocolViolationException">
            If the response code in invalid, see above.
            </exception>
            
            <exception ><!-- NO cref="" -->For other possible exceptions see <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </exception>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)">
            <summary>
            Overloaded <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(System.Boolean,Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>
            with <c>isResponseToConnect</c> defaulted to false.
            </summary>
            <param name="responseCode">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(System.Boolean,Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <param name="headers">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(System.Boolean,Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <param name="bodyStream">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(System.Boolean,Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <returns>See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(System.Boolean,Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </returns>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(System.Boolean,Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)">
            <summary>
            Overloaded <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(System.Boolean,System.Byte[],Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>
            but using the shared buffer as returned by <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.GetSendBuffer"/>
            </summary>
            <param name="isResponseToConnect">
            Whether the response is to a Connect PDU and thus should include the
            extra Connect bytes.
            </param>
            <param name="responseCode">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(System.Boolean,System.Byte[],Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <param name="headers">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(System.Boolean,System.Byte[],Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <param name="bodyStream">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(System.Boolean,System.Byte[],Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <returns>See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(System.Boolean,System.Byte[],Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </returns>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.CreateResponse(System.Boolean,System.Byte[],Brecham.Obex.Pdus.ObexResponseCode,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)">
            <overloads>
            Create a response PDU, optionally as a response to a Connect PDU, 
            and validity checks the resultant PDU.
            </overloads>
            ----
            <summary>
            Create a response PDU, optionally as a response to a Connect PDU, 
            and validity checks the resultant PDU.
            </summary>
            -
            <remarks>
            <para>
            If creating a response to a Connect PDU the extra Connect bytes
            will be added,
            they define the protocol version in use and the maximum packet size.
            The latter is as set at initialisation with <c>bufferSize</c>, or 
            subsequently with
            <see cref="P:Brecham.Obex.Pdus.ObexPduFactory.LocalMru"/>.
            </para><para>
            The response code is checked for validity, for instance throwing 
            <see cref="T:System.Net.ProtocolViolationException"/> if the &#x2018;final&#x2019;
            bit is clear.  See OBEX13.pdf sections 3.2 and 3.2.1.
            </para>
            </remarks>
            --
            <param name="isResponseToConnect">
            This response is to a Connect PDU, so the extra Connect bytes will be added.
            </param>
            <param name="buffer">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <param name="responseCode">
            The Response code to include in the PDU,
            as an <see cref="T:Brecham.Obex.Pdus.ObexResponseCode"/>.
            </param>
            <param name="headers">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            <param name="bodyStream">See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </param>
            -
            <returns>See <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </returns>
            -
            <exception cref="T:System.Net.ProtocolViolationException">
            If the response code in invalid, see above.
            </exception>
            <!-- NO cref="" ... -->
            <exception >For other possible exceptions see <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/>.
            </exception>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)">
            <overloads>
            Creates a PDU with the given code byte, optional headers,
            and optional <c>Stream</c> to read into a body header.
            </overloads>
            --
            <summary>
            Creates a PDU with the given code byte, optional headers,
            and optional <c>Stream</c> to read into a body header.
            Creates the PDU in the shared buffer.
            </summary>
            -
            <param name="code">        
            The code value for the PDU, as a <see cref="T:System.Byte"/>.
            </param>
            <param name="headers">
            Optionally, an <see cref="T:Brecham.Obex.ObexHeaderCollection"/> containing 
            the headers to be added to the PDU.
            </param>
            <param name="bodyStream">
            Optionally, a <see cref="T:System.IO.Stream"/> from which content is to be 
            read and added as a <c>Body</c> header to the end of the PDU.  If 
            supplied, there must be no <c>Body</c> or <c>EndOfBody</c> header in
            the <c>headers</c> collection.
            </param>
            -
            <returns>An instance of <see cref="T:Brecham.Obex.Pdus.ObexCreatedPdu"/>
            containing the created PDU as a byte array.
            </returns>
            -
            <exception cref="T:Brecham.Obex.Pdus.ObexCreateTooLongException">
            The buffer was too small to contain the created PDU containing even the first 
            of the headers.  As noted above, if at least one header _was_ written,
            then the PDU is returned, and the headers that were not added remain 
            in the <c>headers</c> collection.
            </exception>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)">
            <summary>
            Creates a PDU with the given code byte, optional headers,
            and optional <c>Stream</c> to read into a body header.
            Creates the PDU in the the specified buffer.
            </summary>
            -
            <param name="buffer">
            The <see cref="T:System.Byte"/> array buffer to create the PDU in.
            </param>
            <param name="code">
            The code value for the PDU, as a <see cref="T:System.Byte"/>.
            </param>
            <param name="headers">
            Optionally, an <see cref="T:Brecham.Obex.ObexHeaderCollection"/> containing 
            the headers to be added to the PDU.
            </param>
            <param name="bodyStream">
            Optionally, a <see cref="T:System.IO.Stream"/> from which content is to be 
            read and added as a <c>Body</c> header to the end of the PDU.  If 
            supplied, there must be no <c>Body</c> or <c>EndOfBody</c> header in
            the <c>headers</c> collection.
            <para>
            Note: If there is not room for at least one byte of body content to be
            added to the PDU, then reading content from the stream is skipped.
            </para>
            </param>
            -
            <returns>An instance of <see cref="T:Brecham.Obex.Pdus.ObexCreatedPdu"/>
            containing the created PDU as a byte array.
            </returns>
            -
            <exception cref="T:System.ArgumentNullException">
            <c>buffer</c> is null.</exception>
            <exception cref="T:System.ArgumentException">
            <para><c>buffer</c> was too small to hold even the minimum PDU.  It must be
            at least <see cref="F:Brecham.Obex.Pdus.ObexPduFactory.MinimumPduLength"/>
            (3) bytes long.</para>
            <para>&#x2013; or &#x2013;</para>
            <para>
            <c>bodyStream</c> is supplied, but the header collection also contains 
            <c>Body</c> or <c>EndOfBody</c> headers.
            </para>
            </exception>
            <exception cref="T:Brecham.Obex.Pdus.ObexCreateTooLongException">
            The buffer was too small to contain the created PDU containing even the first 
            of the headers.  As noted above, if at least one header _was_ written,
            then the PDU is returned, and the headers that were not added remain 
            in the <c>headers</c> collection.
            </exception>
            <exception cref="T:System.IO.IOException">
            An error occured on reading from <paramref name="bodyStream"/>
            </exception>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponse(System.Byte[],System.Int32)">
            <summary>
            Parse the response PDU contained in the given byte array.
            </summary>
            <remarks>
            Other overloads exists to allow parsing of responses of CONNECT PDUs, see
            <see cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponse(System.Boolean,System.Byte[],System.Int32)"/>
            and 
            <see cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponseToConnect(System.Byte[],System.Int32)"/>
            .
            </remarks>
            <param name="buffer">
            A byte array containing the PDU, starting at index zero.
            </param>
            <param name="length">
            The length of the PDU contained in the buffer.
            </param>
            <returns>An instance of 
            <see cref="T:Brecham.Obex.Pdus.ObexParsedResponsePdu"/> initialised with
            the result of the parsing operation.
            </returns>
            <seealso cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponse(System.Boolean,System.Byte[],System.Int32)"/>
            <seealso cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponseToConnect(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponseToConnect(System.Byte[],System.Int32)">
            <summary>
            Parse the CONNECT response PDU contained in the given byte array.
            </summary>
            <remarks>
            The extra 'connect' bytes are checked and 
            the value from their maximum packet length field is used to set the
            <see cref="P:Brecham.Obex.Pdus.ObexPduFactory.PeerMru"/> value.
            </remarks>
            <param name="buffer">
            A byte array containing the PDU, starting at index zero.
            </param>
            <param name="length">
            The length of the PDU contained in the buffer.
            </param>
            <returns>An instance of 
            <see cref="T:Brecham.Obex.Pdus.ObexParsedResponsePdu"/> initialised with
            the result of the parsing operation.
            </returns>
            <seealso cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponse(System.Byte[],System.Int32)"/>
            <seealso cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponse(System.Boolean,System.Byte[],System.Int32)"/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponse(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            Parse the normal or CONNECT response PDU contained in the given byte array.
            </summary>
            <remarks>
            If the PDU is a CONNECT response the extra 'connect' bytes are checked and 
            the value from their maximum packet length field is used to set the 
            <see cref="P:Brecham.Obex.Pdus.ObexPduFactory.PeerMru"/> value.
            </remarks>
            <param name="isResponseToConnect">
            Whether the PDU is a response to a CONNECT PDU, or is simply a response to 
            any other PDU type.
            </param>
            <param name="buffer">
            A byte array containing the PDU, starting at index zero.
            </param>
            <param name="length">
            The length of the PDU contained in the buffer.
            </param>
            <returns>An instance of 
            <see cref="T:Brecham.Obex.Pdus.ObexParsedResponsePdu"/> initialised with
            the result of the parsing operation.
            </returns>
            <seealso cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponse(System.Byte[],System.Int32)"/>
            <seealso cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponseToConnect(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.ParseForLength(System.Byte[],System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Check whether we have all the bytes that the PDU contains.
            </summary>
            <remarks>
            Check whether we have all the bytes that the PDU contains.
            <list type="number">
            <item>If the buffer contains *exactly* the expectedReqs number of bytes 
            then extraLengthRequired is ZERO.
            </item><item>
            If the buffer has *less* bytes than required then 
            extraLengthRequired is POSITIVE.  The caller should read that number 
            of bytes from the stream or socket and re-call this function.
            </item><item>
            If the nbuffer gas *more* bytes than required then 
            extraLengthRequired is NEGATIVE.  
            </item>
            </list>
            </remarks>
            -
            <exception cref="T:System.ArgumentNullException">
              <paramref name="buffer"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="length"/> is invalid, must be positive and within the range of 
            <see cref="F:MaximumMru"/>, 
            ie the range of <see cref="T:System.UInt16"/>.
            </exception>
            <exception cref="T:System.Net.ProtocolViolationException">
            The length field in the PDU is invalid, for instance has a value less 
            than the minimum (3).
            </exception>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.ParseForLength(System.Boolean,System.Byte[],System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Check whether we have all the bytes that the PDU contains.  Throws if
            the PDU being received is bigger than the receive buffer.  This
            should not happen, as we told the peer at connect time
            what size our buffer was.
            </summary>
            <remarks>
            Check whether we have all the bytes that the PDU contains.  Throws if
            the PDU being received is bigger than the receive buffer.  This
            should not happen, as we told the peer at connect time
            what size our buffer was.
            <list type="number">
            <item>If the buffer contains *exactly* the expectedReqs number of bytes 
            then extraLengthRequired is ZERO.
            </item><item>
            If the buffer has *less* bytes than required then 
            extraLengthRequired is POSITIVE.  The caller should read that number 
            of bytes from the stream or socket and re-call this function.
            </item><item>
            If the nbuffer gas *more* bytes than required then 
            extraLengthRequired is NEGATIVE.  
            </item>
            </list>
            </remarks>
            -
            <exception cref="T:System.ArgumentNullException">
              <paramref name="buffer"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="length"/> is invalid, must be positive and within the range of 
            <see cref="F:MaximumMru"/>, 
            ie in the range of <see cref="T:System.UInt16"/>.
            </exception>
            <exception cref="T:System.Net.ProtocolViolationException">
            <para>
            The length field in the PDU is invalid, for instance has a value less 
            than the minimum (3).
            </para>
            <para>– or –</para>
            <para>
            The PDU being received is bigger than the local maximum receive size 
            (<see cref="P:Brecham.Obex.Pdus.ObexPduFactory.LocalMru"/>).
            </para>
            </exception>
        </member>
        <member name="M:Brecham.Obex.Pdus.ObexPduFactory.Parse(Brecham.Obex.Pdus.ObexPduType,System.Byte[],System.Int32)">
            <summary>
            Parse the PDU contained in the given byte array.
            </summary>
            -
            <remarks>
            This method simply parses the PDU and returns its content.
            In most cases the higher level <c>ParseResponse</c> and 
            <c>ParseResponseToConnect</c> methods will be preferable.  They also check
            and use the extra 'connect' bytes in CONNECT responses.
            </remarks>
            -
            <param name="type">
            The type of PDU to be parsed, as a <see cref="T:Brecham.Obex.Pdus.ObexPduType"/>,
            whether a request or response PDU, and if a response whether it is a response
            to a CONNECT operation or to any other PDU type.
            </param>
            <param name="buffer">
            A byte array containing the PDU, starting at index zero.
            </param>
            <param name="length">
            The length of the PDU contained in the buffer.
            </param>
            -
            <returns>
            Depending on the type PDU parsed, an instance of 
            <see cref="T:Brecham.Obex.Pdus.ObexParsedRequestPdu"/> or
            <see cref="T:Brecham.Obex.Pdus.ObexParsedResponsePdu"/> initialised with
            the result of the parsing operation.
            </returns>
            -
            <seealso cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponse(System.Boolean,System.Byte[],System.Int32)"/>
            <seealso cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponse(System.Byte[],System.Int32)"/>
            <seealso cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponseToConnect(System.Byte[],System.Int32)"/>
            -
            <exception cref="T:System.ArgumentNullException">
              <paramref name="buffer"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The length of the PDU (int its length field) is longer than <paramref name="length"/>.
            </exception>
            <exception cref="T:System.Net.ProtocolViolationException">
            The PDU is invalid; one of its fields or header overruns, or one of the
            headers is in an invalid format, for instance a non-null-terminated string.
            </exception>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexPduFactory.LocalMru">
            <summary>
            Gets or set the size of our receive buffer.
            </summary>
            -
            <remarks>
            This is a supplied as <c>bufferSize</c> in the 
            <see cref="M:Brecham.Obex.Pdus.ObexPduFactory.#ctor(System.Int32)"/>
            constructor.
            <para>
            See <see cref="F:Brecham.Obex.Pdus.ObexPduFactory.MinimumMru"/> and
            <see cref="F:Brecham.Obex.Pdus.ObexPduFactory.MaximumMru"/> for size 
            restrictions
            </para>
            </remarks>
            -
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is not in the valid range.
            </exception>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexPduFactory.PeerMru">
            <summary>
            Gets or set the size of the peer device's receive buffer.  
            </summary>
            <remarks>
            This defaults to 255 as specified in Obex13.pdf section 3.3.1.3, and 
            the peer device advertises its actual value in the Connect PDU.  The 
            peer's actual value is thus discovered if a Connect operation is executed.
            The <see cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseResponse(System.Boolean,System.Byte[],System.Int32)"/>
            method and its caller will use the advertised value if it is called on
            a Connect PDU.
            <para>
            See <see cref="F:Brecham.Obex.Pdus.ObexPduFactory.MinimumMru"/> and
            <see cref="F:Brecham.Obex.Pdus.ObexPduFactory.MaximumMru"/> for size 
            restrictions
            </para>
            </remarks>
            -
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is not in the valid range.
            </exception>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexPduFactory.Mtu">
            <summary>
            Get or set the local Maximum Transmission Unit, that is our maximum send
            size.
            </summary>
            <remarks>
            <para>
            This can be used to restrict the maximum sized PDU we will send, for 
            instance as OBEX13.pdf section 3.3.1.3 states:
            &#x201C;&#x2026;packet sizes should be intelligently limited on slower 
            links to reduce abort request latency.&#x201D;
            </para><para>
            See <see cref="F:Brecham.Obex.Pdus.ObexPduFactory.MinimumMru"/> and
            <see cref="F:Brecham.Obex.Pdus.ObexPduFactory.MaximumMru"/> for size 
            restrictions
            The value can be reset by calling
            <see cref="M:Brecham.Obex.Pdus.ObexPduFactory.ClearMtu"/>
            </para>
            </remarks>
            -
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is not in the valid range.
            </exception>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexPduFactory.MaxSendPduLength">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexPduFactory.MaxSendBodyLength">
            <exclude/>
        </member>
        <member name="T:Brecham.Obex.Pdus.ObexParsedPdu">
            <summary>
            Contains the result of parsing a PDU.
            </summary>
            <remarks>
            This an abstract base class (<c>MustImplement</c> in Visual Basic), the 
            instance returned by the parsing operation will be an instance of either 
            <see cref="T:Brecham.Obex.Pdus.ObexParsedRequestPdu"/> or
            <see cref="T:Brecham.Obex.Pdus.ObexParsedResponsePdu"/>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexParsedPdu.Code">
            <summary>
            Get the value of the code byte from the parsed PDU.
            </summary>
            <remarks>
            If a Response PDU was parsed, then an instance of <c>ObexParsedResponsePdu</c>
            is returned and its 
            <see cref="P:Brecham.Obex.Pdus.ObexParsedResponsePdu.ResponseCode"/>
            property should be used.
            Otherwise if a Request PDU was parsed, then an instance of 
            <c>ObexParsedRequestPdu</c>
            is returned and its 
            <see cref="P:Brecham.Obex.Pdus.ObexParsedRequestPdu.Opcode"/>
            property should be used.
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexParsedPdu.Headers">
            <summary>
            Get the headers from the parsed PDU, as a 
            <see cref="T:Brecham.Obex.ObexHeaderCollection"/>.
            </summary>
            <remarks>
            If the PDU contains no headers an empty collection is returned.
            Note that any extra pre-headers bytes as used in the Connnect PDUs and
            in SetPath request PDUs are returned as a header with id
            <see cref="F:Brecham.Obex.ObexHeaderId.ProxyPreHeadersBytes"/>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexParsedPdu.ExtraLength">
            <summary>
            Get the number of bytes remaining in the buffer when the PDU was read from it.
            </summary>
            <remarks>
            The PDU contains a length field so the parser knows how many of the bytes
            in the buffer are for the first PDU.  If there are any left over the 
            count is set here.
            If using <c>ReadAPdu</c> or <see 
            cref="M:Brecham.Obex.Pdus.ObexPduFactory.ParseForLength(System.Boolean,System.Byte[],System.Int32,System.Int32@,System.Int32@)"/>
            then the buffer should contain one PDU and no extra bytes and thus this
            property will have value zero.
            </remarks>
        </member>
        <member name="T:Brecham.Obex.Pdus.ObexParsedResponsePdu">
            <summary>
            Contains the result of parsing a Response PDU.
            </summary>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexParsedResponsePdu.ResponseCode">
            <summary>
            Get the value of the Response Code byte from the parsed PDU.
            </summary>
            <value>
            An <see cref="T:Brecham.Obex.Pdus.ObexResponseCode"/> value.
            </value>
        </member>
        <member name="T:Brecham.Obex.Pdus.ObexParsedRequestPdu">
            <summary>
            Contains the result of parsing a Request PDU.
            </summary>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexParsedRequestPdu.Opcode">
            <summary>
            Get the value of the Opcode byte from the parsed PDU.
            </summary>
            <value>
            A <see cref="T:Brecham.Obex.Pdus.ObexOpcode"/>.
            </value>
        </member>
        <member name="T:Brecham.Obex.Pdus.ObexCreatedPdu">
            <summary>
            The result of a creating a PDU creation.  It contains the byte array containing
            the PDU, and its length.
            </summary>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexCreatedPdu.Buffer">
            <summary>
            Gets the created PDU.
            </summary>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexCreatedPdu.Length">
            <summary>
            Gets the length of the PDU created.
            </summary>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexCreatedPdu.BodyStreamLength">
            <summary>
            Get the number of bytes from the <c>bodyStream</c> that were added to the
            PDU as a <c>Body</c> header.
            </summary>
        </member>
        <member name="P:Brecham.Obex.Pdus.ObexCreatedPdu.EndOfBodyStream">
            <summary>
            Get whether the <c>bodyStream</c> was read, and it was found that
            the end of the stream had been reached.
            </summary>
            <remarks>
            This value is <c>true</c> if: a non-null <c>bodyStream</c> argument was passed to
            <see cref="M:Brecham.Obex.Pdus.ObexPduFactory.Create(System.Byte[],System.Byte,Brecham.Obex.ObexHeaderCollection,System.IO.Stream)"/> etc, there was space for at
            least one byte of body data to be added to the PDU, and on reading the
            stream it returned a length of zero (0) indicating that
            "the end of the stream has been reached."
            (see <c>Stream.</c><see
            cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32"/>).
            </remarks>
        </member>
        <member name="T:Brecham.Obex.Objects.StrippingEnabled">
            <summary>
            Specifies values to indicate whether the 
            <see cref="T:Brecham.Obex.Objects.ObexFolderListingParser"/> should strip the
            <c>DOCTYPE</c> element and null bytes if present in the document.
            </summary>
            <remarks>
            This class is used when setting the 
            <see cref="P:Brecham.Obex.Objects.ObexFolderListingParser.StripDocType"/>, and
            <see cref="P:Brecham.Obex.Objects.ObexFolderListingParser.StripNullBytes"/>
            properties on class 
            <see cref="T:Brecham.Obex.Objects.ObexFolderListingParser"/>.
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Objects.StrippingEnabled.Default">
            <summary>
            The default setting for the current platform will be used.
            </summary>
        </member>
        <member name="F:Brecham.Obex.Objects.StrippingEnabled.No">
            <summary>
            Stripping will _not_ be carried.
            </summary>
        </member>
        <member name="F:Brecham.Obex.Objects.StrippingEnabled.Yes">
            <summary>
            Stripping _will_ be carried.
            </summary>
        </member>
        <member name="T:Brecham.Obex.Objects.XmlDocTypeStripperStream">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.XmlDocTypeStripperStream.#ctor(System.IO.Stream)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.XmlDocTypeStripperStream.Dispose(System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.XmlDocTypeStripperStream.Read(System.Byte[],System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.XmlDocTypeStripperStream.ReadStripping(System.Byte[],System.Int32,System.Int32,System.Boolean@)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.XmlDocTypeStripperStream.ReadStrippingOnGivenData(System.Byte[],System.Int32,System.Int32,System.Boolean@,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.XmlDocTypeStripperStream._BeforeDoctype(System.Byte[],System.Int32,System.Int32,System.Boolean@,System.Int32@)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.XmlDocTypeStripperStream._InDoctypeElement(System.Byte[],System.Int32,System.Int32,System.Boolean@,System.Int32@)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.XmlDocTypeStripperStream.Write(System.Byte[],System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.XmlDocTypeStripperStream.Flush">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.XmlDocTypeStripperStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.XmlDocTypeStripperStream.SetLength(System.Int64)">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.Objects.XmlDocTypeStripperStream.CanRead">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.Objects.XmlDocTypeStripperStream.CanSeek">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.Objects.XmlDocTypeStripperStream.CanWrite">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.Objects.XmlDocTypeStripperStream.Length">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.Objects.XmlDocTypeStripperStream.Position">
            <exclude/>
        </member>
        <member name="T:Brecham.Obex.Objects.NullByteStripperStream">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.NullByteStripperStream.#ctor(System.IO.Stream)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.NullByteStripperStream.Dispose(System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.NullByteStripperStream.Read(System.Byte[],System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.NullByteStripperStream.Write(System.Byte[],System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.NullByteStripperStream.Flush">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.NullByteStripperStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.NullByteStripperStream.SetLength(System.Int64)">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.Objects.NullByteStripperStream.CanRead">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.Objects.NullByteStripperStream.CanSeek">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.Objects.NullByteStripperStream.CanWrite">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.Objects.NullByteStripperStream.Length">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.Objects.NullByteStripperStream.Position">
            <exclude/>
        </member>
        <member name="T:Brecham.Obex.Objects.ObexXmlUtilities">
            <summary>
            Miscellaneous functions to help create and use the FCL Xml classes, for instance
            dealing with creating the <see cref="T:System.Xml.XmlReaderSettings"/> required
            for secure creation of an <see cref="T:System.Xml.XmlReader"/>, and creation of
            an <see cref="T:System.Xml.XmlException"/> which
            includes the line and position numbers in its message 
            as the FCL created exception instances do.
            </summary>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexXmlUtilities.CreateXmlReader(System.IO.Stream)">
            <summary>
            Creates a new <c>System.Xml.XmlReader</c> instance using the specified stream,
            configured with the <c>XmlReaderSettings</c> and <c>XmlResolver</c>
            required by the local parsers.
            </summary>
            <param name="input">
                The <c>stream</c> containing the XML data. The <c>System.Xml.XmlReader</c> scans the first
                bytes of the stream looking for a byte order mark or other sign of encoding.
                When encoding is determined, the encoding is used to continue reading the
                stream, and processing continues parsing the input as a stream of (Unicode)
                characters.
            </param>
            <returns>
            An <c>System.Xml.XmlReader</c> object used to read the data contained in the stream
            </returns>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexXmlUtilities.CreateXmlReader(System.IO.TextReader)">
            <summary>
            Creates a new <c>System.Xml.XmlReader</c> instance using the specified <c>System.IO.TextReader</c>,
            configured with the <c>XmlReaderSettings</c> and <c>XmlResolver</c>
            required by the local parsers.
            </summary>
            <param name="input">
                The <c>System.IO.TextReader</c> from which to read the XML data. Because a 
            <c>System.IO.TextReader</c>
                returns a stream of Unicode characters, he encoding specified in the XML
                declaration is not used by the <c>System.Xml.XmlReader</c> to decode the data stream
            </param>
            <returns>
            An System.Xml.XmlReader object used to read the data contained in the stream
            </returns>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexXmlUtilities.CreateXmlReaderSettings">
            <summary>
            Create an <see cref="T:System.Xml.XmlReaderSettings"/> object configured
            to use the library's <c>XmlResolver</c> and with other suitable settings.
            </summary>
            <remarks>
            The settings are configured as follows.  For validation and DTD handling, 
            the <see cref="T:Brecham.Obex.Objects.ObexXmlResolver"/> is supplied and
            <see cref="P:System.Xml.XmlReaderSettings.ProhibitDtd"/> and 
            <see cref="P:System.Xml.XmlReaderSettings.ValidationType"/> are set 
            respectively.  On the general settings, 
            <see cref="P:System.Xml.XmlReaderSettings.CloseInput"/> is set to 
            <c>true</c> so that the input <c>Stream</c> is closed when the 
            <c>XmlReader</c> is closed.
            </remarks>
            <returns>An <see cref="T:System.Xml.XmlReaderSettings"/> instance,
            configured as discussed below.</returns>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexXmlUtilities.CreateXmlException(System.Xml.XmlReader,System.String)">
            <summary>
            Create an <see cref="T:System.Xml.XmlException"/>
            including the given message and the line number and 
            position on the line as the exceptions thrown by the FCL's XmlReaders do.
            </summary>
            <remarks>The message on the resultant exception will be of the form:
            <code><c>&lt;message&gt;</c> + " Line <c>&lt;L&gt;</c>, position <c>&lt;M&gt;</c>."</code>
            </remarks>
            <param name="xr">The <see cref="T:System.Xml.XmlReader"/> that is active.
            The line and character postions will be read from it, if it supports those properties.</param>
            <param name="message">The exception message.</param>
            <returns></returns>
        </member>
        <member name="T:Brecham.Obex.Objects.ObexXmlResolver">
            <summary>
            An <see cref="T:System.Xml.XmlResolver"/> that knows how to 
            access the OBEX object DTDs, without any remote lookups.
            </summary>
            -
            <remarks>
            <para>At the current time the <c>obex-folder-listing.dtd</c> and 
            <c>obex-capability.dtd</c> DTDs are present.
            </para>
            <para>Two versions of the Folder-Listing DTD are included, the one from the
            OBEX specification, and one that is modified to be slightly less strict which 
            is required to suit the format of listings produced by various devices.  See 
            <see cref="P:Brecham.Obex.Objects.ObexXmlResolver.UseVerbatimFolderListingsDtd"/>
            for more information.
            </para>
            </remarks>
            -
            <example>
            <code lang="Visual Basic">
            Dim xr As XmlTextReader = New System.Xml.XmlTextReader(content) 
            xr.XmlResolver = New Objects.ObexXmlResolver 
            If Not xr.Read Then ...
            If xr.NodeType ...
            </code>
            </example>
        </member>
        <member name="F:Brecham.Obex.Objects.ObexXmlResolver.ErrorMsgUnknownDtd">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Objects.ObexXmlResolver.ErrorMsgTypeNotStream">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexXmlResolver.Create">
            <summary>
            Returns an instance of the <c>ObexXmlResolver</c> class, this is  
            equivalent to calling <c>new ObexXmlResolver()</c>.
            </summary>
            <remarks>
            Returns an instance of the <c>ObexXmlResolver</c> class, this is  
            equivalent to calling <c>new ObexXmlResolver()</c>.
            It is provided so that if a developer,
            instead of typing <c>new ObexXmlResolver()</c>, has instead
            typed the class name and thus Intellisense  lists the member functions.  
            This member can then be selected to create the new instance.
            </remarks>
            <returns>An instance of the <c>ObexXmlResolver</c> class.</returns>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexXmlResolver.#ctor">
            <summary>
            Creates an instance of the <c>ObexXmlResolver</c> class, for instance to 
            use with a <see cref="T:System.Xml.XmlReader"/>.  See the example in the
            class level documentation (<see cref="T:ObexXmlResolver"/>).
            </summary>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexXmlResolver.GetEntity(System.Uri,System.String,System.Type)">
            <summary>
            Maps a URI to an object containing the requested DTD, if the DTD is one
            of those defined in the OBEX specification.  Uses resources embedded in the
            library and thus make no remote lookups.
            </summary>
            <param name="absoluteUri">The URI returned from <c>ResolveUri</c>.</param>
            <param name="role">Not used currently.</param>
            <param name="ofObjectToReturn">The type of object to return. The current 
            version only returns System.IO.Stream objects.</param>
            <returns>A System.IO.Stream object or a null reference (Nothing in Visual 
            Basic) if a type other than stream is specified. </returns>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexXmlResolver.GetResource(System.String)">
            <exclude/>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexXmlResolver.UseVerbatimFolderListingsDtd">
            <summary>
            Get or set whether the Resolver will use the original DTD or the modified one.
            </summary>
            -
            <value>
            <see langword="true"/> if the original DTD will be used; 
            <see langword="false"/> if the modified DTD will be used 
            &#x2014; which allows an empty value for the user-perm (etc) attributes. 
            The default is <see langword="false"/>.
            </value>
            -
            <remarks>
            <para>The DTD from the OBEX specification (OBEX13.pdf) defines 
            the &#x201C;user-perm&#x201D;, &#x201C;group-perm&#x201D;, and 
            &#x201C;other-perm&#x201D; attributes as being of type <c>NMTOKEN</c>
            , i.e. requiring them to have a value which is a valid XML Name.
            However the specification of their content appears to 
            say that an empty string value is valid (to represent no permissions). 
            That is thus inconsistent and a validating XML parser will disallow such an 
            attribute with an empty string.
            Various devices produce listing containing such a value, so they fail 
            the parser&#x2019;s validation.
            A modified listing included in the library uses the <c>CDATA</c> type 
            for those attributes and thus will accept the empty string.
            </para>
            <para>Devices known to produce such listings include mobile-phones
            from LG and SonyEricsson.
            </para>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexXmlResolver.Credentials">
            <summary>
            Not supported.  This resolver only accesses the OBEX DTDs that are contained
            within the assembly so no credentials are required.
            </summary>
        </member>
        <member name="T:Brecham.Obex.Objects.CapabilityObjectParser">
            <summary>
            Provides means to use OBEX Capability objects, which are XML documents.
            See OBEX13.pdf section 9.3.  This parser is not implemented.
            </summary>
            <remarks>
            Provides means to use OBEX Capability objects, which are XML documents.
            See OBEX13.pdf section 9.3.  This parser is not implemented.  To create a 
            parser externally create a <see cref="T:System.Xml.XmlReader"/> with
            <see cref="M:Brecham.Obex.Objects.ObexXmlUtilities.CreateXmlReader(System.IO.Stream)"/>
            etc, which return an <c>XmlReader</c> instance configured 
            with suitable settings and an <see cref="T:Brecham.Obex.Objects.ObexXmlResolver"/> 
            which can supply the capability-object DTD from within the assembly.
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Objects.CapabilityObjectParser.DtdName">
             <summary>
             The name of the DTD for this document type.
             </summary>
            -
            <remarks>
             <para>Please consider using the new 
             <see cref="F:Brecham.Obex.Objects.CapabilityObjectParser.SystemIdentifier"/>
             or <see cref="F:Brecham.Obex.Objects.CapabilityObjectParser.DocTypeName"/>
             fields.
             </para>
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Objects.CapabilityObjectParser.DocTypeName">
            <summary>
            The name of the DOCTYPE for this document type, 
            this is thus also the name of the root element.
            </summary>
            -
            <remarks>
            Has value <c>Capability</c>.
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Objects.CapabilityObjectParser.SystemIdentifier">
            <summary>
            The system identifier of the DTD for this document type.
            </summary>
            -
            <remarks>
            Has value <c>obex-capability.dtd</c>.
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.CapabilityObjectParser.Dtd">
            <summary>
            Returns a <see cref="T:System.IO.Stream"/> containing the DTD for the
            Capability object, from OBEX13.pdf section 9.3.6.  The DTD is 
            embedded in the assembly and thus no remote lookups are required.
            </summary>
            <remarks>Note, if using the DTD with <c>System.Xml.XmlReader</c> for instance
            then it is not necessary to access it directly through this method, instead
            have the <c>XmlReader</c> use the supplied XmlResolver
            (<see cref="T:Brecham.Obex.Objects.ObexXmlResolver"/>), or use the utility 
            method that returns an XmlReader configured in that way 
            e.g. <see cref="M:Brecham.Obex.Objects.ObexXmlUtilities.CreateXmlReader(System.IO.Stream)"/>.
            </remarks>
            <returns>A <see cref="T:System.IO.Stream"/> containing the DTD for the
            Capability object.</returns>
        </member>
        <member name="T:Brecham.Obex.Objects.ObexFolderListing">
            <summary>
            Holds the items from a parsed OBEX Folder-listing XML document.  As returned
            by <c>ObexClientSession.</c><see cref="M:Brecham.Obex.ObexClientSession.GetFolderListing"/>,
            and <c>ObexFolderListingParser.</c><see cref="M:Brecham.Obex.Objects.ObexFolderListingParser.GetAllItems"/>.
            Provides access to a list of all the items, and also access to lists of the component
            <c>folder</c>s, <c>file</c>s, and whether the list contains a <c>parent-folder</c>.
            </summary>
            <example>
            <code lang="Visual Basic">
            Private Sub DisplayFolderListing(sess As ObexClientSession)
               Dim xmlFl As Stream = sess.Get(Nothing, ObexConstant.Type.FolderListing)
               Dim parser As New ObexFolderListingParser(xmlFl)
               Dim listing As ObexFolderListing = parser.GetAllItems
               If (listing.HasParentFolder) Then Console.WriteLine("&lt;DIR&gt; ..")
               For Each folder As ObexFolderItem In listing.Folders
                  Console.WriteLine("&lt;DIR&gt; {0}", folder.Name)
               Next
               For Each file As ObexFileItem In listing.Files
                  Console.WriteLine("      {0}", file.Name)
               Next
            End Sub
            </code>
            Note: This example shows the separate requesting the Get of the listing, 
            and then its parsing.  These two steps are combined in the method
            <c>ObexClientSession.</c><see cref="M:Brecham.Obex.ObexClientSession.GetFolderListing"/>.
            </example>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFolderListing.#ctor(System.Collections.Generic.IList{Brecham.Obex.Objects.ObexFolderListingItem})">
            <summary>
            Initialises a new instance of the <c>ObexFolderListing</c> class to hold
            the list of items indicated by the list instance
            </summary>
            <remarks>
            <note>
            Apologies for the untidy text in this member&#x2019;s and its siblings&#x2019;
            header, this is the Generic type parameter which NDoc, the documentation
            generator, is not yet able to handle.
            </note>
            </remarks>
            <param name="items">The list of 
            <see cref="T:Brecham.Obex.Objects.ObexFolderListingItem"/> whose 
            items is to be held in this instance.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The <c>items</c> is a null reference (<c>Nothing</c> in Visual Basic).
            </exception>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFolderListing.HasParentFolder">
            <summary>
            &#x201C;Represents the existence of a parent to the folder being presented.&#x201D;
            </summary>
            <remarks>
            In effect whether the list of items contains a 
            <see cref="T:Brecham.Obex.Objects.ObexParentFolderItem"/> item.
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFolderListing.Folders">
            <summary>
            The <c>folder</c> items in the document, as a list of 
            <see cref="T:Brecham.Obex.Objects.ObexFolderItem"/> instances.
            </summary>
            <remarks>
            A folder item 
            “Indicates the existence of a folder contained within the folder.”
            If there are no items, a non-null empty list is returned.  
            <note>
            Apologies for the untidy text in this member’s and its siblings’
            header, this is the Generic type parameter which NDoc, the documentation
            generator, is not yet able to handle.
            </note>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFolderListing.Files">
            <summary>
            The <c>file</c> items in the document, as a list of 
            <see cref="T:Brecham.Obex.Objects.ObexFileItem"/> instances.
            </summary>
            <remarks>
            A file item 
            “Indicates the existence of a file contained within the folder.”
            If there are no items, a non-null empty list is returned.
            <note>
            Apologies for the untidy text in this member’s and its siblings’
            header, this is the Generic type parameter which NDoc, the documentation
            generator, is not yet able to handle.
            </note>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFolderListing.AllItems">
            <summary>
            All the items in the document, as a list of type 
            <see cref="T:Brecham.Obex.Objects.ObexFolderListingItem"/>.
            </summary>
            <remarks>
            <para>Each element 
            in the list is an instance of one of its subclasses: 
            <see cref="T:Brecham.Obex.Objects.ObexFileItem"/>,
            <see cref="T:Brecham.Obex.Objects.ObexFolderItem"/>, or
            <see cref="T:Brecham.Obex.Objects.ObexParentFolderItem"/>.
            If there are no items, a non-null empty list is returned.
            </para>
            <note>
            Apologies for the untidy text in this member’s and its siblings’
            header, this is the Generic type parameter which NDoc, the documentation
            generator, is not yet able to handle.
            </note>
            </remarks>
        </member>
        <member name="T:Brecham.Obex.Objects.ObexFolderListingItem">
            <summary>
            Holds an OBEX Folder-Listing XML item, this the abstract base class from 
            which the 
            <see cref="T:Brecham.Obex.Objects.ObexParentFolderItem"/>,
            <see cref="T:Brecham.Obex.Objects.ObexFolderItem"/>, and
            <see cref="T:Brecham.Obex.Objects.ObexFileItem"/>, 
            concrete instances are created.  Note that the last two share the same 
            attributes and are thus derived from an intermediate abstract class
            <see cref="T:Brecham.Obex.Objects.ObexFileOrFolderItem"/>.
            </summary>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFolderListingItem.ToString">
            <exclude/>
        </member>
        <member name="T:Brecham.Obex.Objects.ObexParentFolderItem">
            <summary>
            Holds an OBEX Folder-Listing XML <c>parent-folder</c> item.
            It is a subclass of the abstract base class
            <see cref="T:Brecham.Obex.Objects.ObexFolderListingItem"/>.
            This item type has no attributes.
            </summary>
            <remarks>
            <para>
            &#x201C;Represents the existence of a parent to the folder being presented.&#x201D;
            </para>
            <para>
            This item type has no attributes, not even a &#x2018;last modified time/date&#x2019;
            property. :-(
            </para>
            </remarks>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexParentFolderItem.Equals(System.Object)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexParentFolderItem.Equals(Brecham.Obex.Objects.ObexParentFolderItem)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexParentFolderItem.GetHashCode">
            <exclude/>
        </member>
        <member name="T:Brecham.Obex.Objects.ObexFileOrFolderItem">
            <summary>
            Holds an OBEX Folder-Listing XML <c>file</c> or <c>folder</c> item,
            this the abstract base class from which the 
            <see cref="T:Brecham.Obex.Objects.ObexFolderItem"/>, and
            <see cref="T:Brecham.Obex.Objects.ObexFileItem"/> concrete instances are 
            created.  It is itself a subclass of the base class
            <see cref="T:Brecham.Obex.Objects.ObexFolderListingItem"/>.
            This item type has multiple attributes.
            </summary>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFileOrFolderItem.#ctor(System.String)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFileOrFolderItem.Equals(System.Object)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFileOrFolderItem.Equals(Brecham.Obex.Objects.ObexFileOrFolderItem)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFileOrFolderItem.GetHashCode">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFileOrFolderItem.ToString">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFileOrFolderItem.ToString(System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFileOrFolderItem.ResetSize">
            <summary>
            Clear the size attribute.
            </summary>
            <remarks>
            Resets the <see cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.HasSize"/>
            property and the size value.
            </remarks>
            <seealso cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.Size"/>
            <seealso cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.HasSize"/>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.Name">
            <summary>
            &#x201C;The name of the folder or file.&#x201D; Read-only.
            </summary>
            <remarks>
            <para>
            &#x201C;The name of the folder or file. It does not include any path or similar
            information. The value of this attribute is used in a <c>NAME</c> header to
            retrieve the object if desired. This value must be unique in all similar
            elements in the document. The current folder may be represented by
            a folder element with the name ".". For example: <c>&lt;folder
            name="."&gt;</c>.&#x201D;
            </para>
            <para>
            The name for an item is constant, and is set a construction time.  This
            property is thus read-only.
            </para>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.Size">
            <summary>
            &#x201C;The size of the folder or file object in bytes. This size is an estimate
            and is not required to be exact.&#x201D;
            </summary>
            <remarks>
            <para>
            &#x201C;The size of the folder or file object in bytes. This size is an estimate
            and is not required to be exact. It is expressed as an unsigned base
            10 integer.&#x201D;
            </para>
            <para>To check if the server provided a value for this attribute use the 
            <see cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.HasSize"/>
            property. (Currently if the server has not provided a size value, then 
            this property will return zero.  Ideally it would return -1 then, but 
            to change that now would be a backwards compatibility break).
            </para>
            <para>
            In testing, a certain Bluetooth stack&#x2019;s OBEX server implementation 
            was seen to return invalid values for large size attributes.  For instance
            a file of size 2,147,483,749 bytes appear in the XML document as 
            &#x201C;-2,147,483,547&#x201D;.  This is an unsigned to signed 32-bit bug
            (2,147,483,749 = 0x80000065, and that as signed is -2,147,483,547).  So 
            if negative numbers appear in a folder-listing result, then suspect the 
            server...
            </para>
            </remarks>
            <seealso cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.HasSize"/>
            <seealso cref="M:Brecham.Obex.Objects.ObexFileOrFolderItem.ResetSize"/>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.HasSize">
            <summary>
            Gets whether the server has provided a size attribute on this folder listing item.
            </summary>
            <value>
            <see langword="true"/> if the server provided a value for this attribute.
            </value>
            <seealso cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.Size"/>
            <seealso cref="M:Brecham.Obex.Objects.ObexFileOrFolderItem.ResetSize"/>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.Type">
            <summary>
            &#x201C;
            This attribute works similarly to the OBEX <c>Type</c> header and
            expresses the MIME type of the file object.&#x201D;
            </summary>
            <remarks>
            &#x201C;This attribute works similarly to the OBEX <c>Type</c> header and
            expresses the MIME type of the file object. It can be used to interpret
            the files’ internal format or an application association.
            &#x201D;</remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.Modified">
            <summary>
            &#x201C;This attribute represents the last modified time for the object.&#x201D;
            </summary>
            <remarks>
            <para>
            &#x201C;This attribute represents the last modified time for the object. It is
            expressed in the same format used by the OBEX ISO <c>Time</c> header.
            That format is YYYYMMDDTHHMMSS, where the capital letter ‘T’ is
            expressly inserted between the day and the hour fields. It is
            recommended that whenever possible UTC time be used. When
            expressing UTC time, the letter “Z” is appended to the end (for
            example: 19670110T153410Z).&#x201D;
            </para>
            <para>If this attribute is unset it will have a value of zero
            <see cref="P:System.DateTime.Ticks"/> and thus be equal to 
            <see cref="F:System.DateTime.MinValue"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.Created">
            <summary>
            &#x201C;This attribute represents the creation time for the object.&#x201D;
            </summary>
            <remarks>
            &#x201C;This attribute represents the creation time for the object. It is
            expressed in the same format used by the OBEX ISO Time header.
            It is recommended that whenever possible UTC time be used.&#x201D;
            <para>If this attribute is unset it will have a value of zero
            <see cref="P:System.DateTime.Ticks"/> and thus be equal to 
            <see cref="F:System.DateTime.MinValue"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.Accessed">
            <summary>
            &#x201C;This attribute represents the last accessed time for the object.&#x201D;
            </summary>
            <remarks>
            &#x201C;This attribute represents the last accessed time for the object. It is
            expressed in the same format used by the OBEX ISO Time header.
            It is recommended that whenever possible UTC time be used.&#x201D;
            <para>If this attribute is unset it will have a value of zero
            <see cref="P:System.DateTime.Ticks"/> and thus be equal to 
            <see cref="F:System.DateTime.MinValue"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.UserPerm">
            <summary>
            The access permissions for the object as applying to the <c>user</c>.
            </summary>
            <remarks>
            <para>
            &#x201C;These attributes convey the access permissions for the object. The
            permissions are encoded based on the access currently available to
            this user over the object listed. The following alphabetic characters
            are used to describe access:
            </para><para>
            “<c>R</c>”, “<c>W</c>”, “<c>D</c>”
            </para><para>
            The value of the permissions type is an unordered sequence of
            these alphabetic characters. The permissions indicators are case
            independent.
            </para><para>
            R: The READ permission applies to all object types. It indicates that
            an attempt to <c>GET</c> the named object should successfully retrieve its
            contents.
            </para><para>
            D: The DELETE permission applies to file types. It indicates that the
            file may be removed by sending a <c>PUT-DELETE</c> command.
            </para><para>
            W: The WRITE permission applies to all object types. It indicates
            that an attempt to modify the contents of the file by <c>PUT</c>’ing to the
            file should succeed. For folder objects it indicates that attempts to
            create a folder or other object within that folder should succeed.
            </para><para>
            There are three levels of permissions. These are for systems that
            distinguish between access for the user, the group and other. The
            default permissions attribute is user.
            </para><para>
            Note: A permission indicator does not imply that the appropriate
            command is guaranteed to work &#x2014; just that it might. Other system
            specific limitations, such as limitations on available space for storing
            objects, may cause an operation to fail, where the permission flags
            may have indicated that it was likely to succeed. The permissions
            are a guide only. Some systems may have more specific
            permissions than those listed here, such systems should map those
            to the flags defined as best they are able.&#x201D;
            </para>
            </remarks>
            <seealso cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.GroupPerm"/>
            <seealso cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.OtherPerm"/>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.GroupPerm">
            <summary>
            The access permissions for the object as applying to the <c>group</c>.
            </summary>
            <remarks>
            The content of this attribute is the same as described for the
            <see cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.UserPerm"/>.
            </remarks>
            <seealso cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.UserPerm"/>
            <seealso cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.OtherPerm"/>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.OtherPerm">
            <summary>
            The access permissions for the object as applying to <c>other</c>s.
            </summary>
            <remarks>
            The content of this attribute is the same as described for the
            <see cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.UserPerm"/>
            </remarks>
            <seealso cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.UserPerm"/>
            <seealso cref="P:Brecham.Obex.Objects.ObexFileOrFolderItem.GroupPerm"/>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.Group">
            <summary>
            &#x201C;Some file systems have the notion of group ownership. This attribute
            is used to convey that information when present&#x201D;
            </summary>
            <remarks>
            &#x201C;Some file systems have the notion of group ownership. This attribute
            is used to convey that information when present&#x201D;
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.Owner">
            <summary>
            &#x201C;The Owner attribute is used to convey the user associated with
            ownership or responsibility for this object.&#x201D;
            </summary>
            <remarks>
            &#x201C;The Owner attribute is used to convey the user associated with
            ownership or responsibility for this object.&#x201D;
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.XmlLang">
            <summary>
            &#x201C;[Specifies] the language of both content and attribute values.&#x201D;
            </summary>
            <remarks>
            &#x201C;The XML defined language attribute may be used to specify the
            language of both content and attribute values. The default language
            of English (us-EN) need not be specified. This attribute affects the
            interpretation of the following attributes: <c>name</c>, <c>owner</c> 
            and <c>group</c>.
            As well as any element content.&#x201D;</remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFileOrFolderItem.DisplayName">
            <summary>
            &#x201C;An optional display name of the file or folder.&#x201D;
            </summary>
            <remarks>
            &#x201C;Both file and folder elements may contain element content. When present, the content expresses the
            recommended display name of the file or folder. This differs from the name attribute in that it does not
            need to be unique or be a valid file/folder name. In the absence of this content, the name attribute should
            be used when displaying the element.&#x201D;
            </remarks>
        </member>
        <member name="T:Brecham.Obex.Objects.ObexFileItem">
            <summary>
            Holds an OBEX Folder-Listing XML <c>file</c> item.
            It is a subclass of the abstract class
            <see cref="T:Brecham.Obex.Objects.ObexFileOrFolderItem"/>.
            which is itself a subclass of the abstract base class
            <see cref="T:Brecham.Obex.Objects.ObexFolderListingItem"/>.
            This item type has multiple attributes.
            </summary>
            <remarks>
            &#x201C;Indicates the existence of a file contained within the folder.&#x201D;
            This item type has multiple attributes.
            </remarks>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFileItem.#ctor(System.String)">
            <summary>
            Initialises a new instance of the <see cref="T:Brecham.Obex.Objects.ObexFileItem"/> class with
            the specified name.
            </summary>
            <param name="name">The name of the file item.</param>
        </member>
        <member name="T:Brecham.Obex.Objects.ObexFolderItem">
            <summary>
            Holds an OBEX Folder-Listing XML <c>folder</c> item.
            It is a subclass of the abstract class
            <see cref="T:Brecham.Obex.Objects.ObexFileOrFolderItem"/>.
            which is itself a subclass of the abstract base class
            <see cref="T:Brecham.Obex.Objects.ObexFolderListingItem"/>.
            This item type has multiple attributes.
            </summary>
            <remarks>
            &#x201C;Indicates the existence of a folder contained within the folder.&#x201D;
            This item type has multiple attributes.
            </remarks>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFolderItem.#ctor(System.String)">
            <summary>
            Initialises a new instance of the <see cref="T:Brecham.Obex.Objects.ObexFolderItem"/> class with
            the specified name.
            </summary>
            <param name="name">The name of the folder item.</param>
        </member>
        <member name="T:Brecham.Obex.Objects.ObexFolderListingParser">
            <summary>
            Provides means to use OBEX Folder-Listing objects, which are XML documents.
            See OBEX13.pdf section 9.1.  In particular it is a parser for the 
            Folder-listing XML documents.
            </summary>
            <remarks>
            <para>
            The class provides a parser to read the OBEX folder-listing XML objects and return
            a list of the <c>parent-folder</c>, <c>folder</c>, and <c>file</c> items that it 
            contains.  It can be used in various ways, firstly via 
            <c>ObexClientSession</c>&#x2019;s
            <see cref="M:Brecham.Obex.ObexClientSession.GetFolderListing"/> method,
            otherwise it can be used directly see the example
            below.  The input is generally the <c>Stream</c> returned by a GET operation 
            for the unnamed item of type <c>x-obex/folder-listing</c> 
            (ie <c>ObexConstant.Type.</c><see cref="F:Brecham.Obex.ObexConstant.Type.FolderListing"/>).
            </para>
            <para>
            In normal usage all the items are returned as an instance of the 
            <see cref="T:Brecham.Obex.Objects.ObexFolderListing"/> class, this is the case for the 
            <see cref="M:Brecham.Obex.Objects.ObexFolderListingParser.GetAllItems"/> method,
            and for the <c>GetFolderListing</c> method on <c>ObexClientSession</c> as mentioned above.
            The <see cref="M:Brecham.Obex.Objects.ObexFolderListingParser.GetNextItem"/> method
            on the other hand returns each individual item as its content arrives, this can
            be used if for instance the download is slow and you want to be show items
            as they arrive before the complete listing has been downloaded.
            </para>
            <para>
            The parser uses the DTD and is also strict even if the document being parsed
            does not reference the DTD, or as on the Compact Framework where <c>XmlReader</c>
            cannot use DTDs.
            During 
            testing it was found that not all devices follow the specification.  The 
            Nokia 6670, for instance, produces documents where the <c>folder</c>
            item can contain <c>mem-type</c> and <c>label</c> attributes.  The 
            <see cref="P:Brecham.Obex.Objects.ObexFolderListingParser.IgnoreUnknownAttributeNames"/>
            property controls whether we will produce an error for undefined attributes, 
            or instead ignore and discard them.
            </para>
            </remarks>
            <example>
            <code lang="Visual Basic">
            Private Sub DisplayFolderListing(sess As ObexClientSession)
               Dim xmlStrm As Stream = sess.Get(Nothing, ObexConstant.Type.FolderListing)
               Dim parser As New ObexFolderListingParser(xmlStrm)
               Dim listing As ObexFolderListing = parser.GetAllItems
               If (listing.HasParentFolder) Then Console.WriteLine("&lt;DIR&gt; ..")
               For Each folder As ObexFolderItem In listing.Folders
                  Console.WriteLine("&lt;DIR&gt; {0}", folder.Name)
               Next
               For Each file As ObexFileItem In listing.Files
                  Console.WriteLine("      {0}", file.Name)
               Next
            End Sub
            </code>
            </example>
        </member>
        <member name="F:Brecham.Obex.Objects.ObexFolderListingParser.ErrorMsgPastLast">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Objects.ObexFolderListingParser.ErrorMsgInvalidStrippingEnabled">
            <exclude/>
        </member>
        <member name="F:Brecham.Obex.Objects.ObexFolderListingParser.DtdName">
             <summary>
             The name of the DTD for this document type.
             </summary>
            -
            <remarks>
             <para>Please consider using the new 
             <see cref="F:Brecham.Obex.Objects.ObexFolderListingParser.SystemIdentifier"/>
             or <see cref="F:Brecham.Obex.Objects.ObexFolderListingParser.DocTypeName"/>
             fields.
             </para>
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Objects.ObexFolderListingParser.DocTypeName">
            <summary>
            The name of the DOCTYPE for this document type, 
            this is thus also the name of the root element.
            </summary>
            -
            <remarks>
            Has value <c>folder-listing</c>.
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Objects.ObexFolderListingParser.SystemIdentifier">
            <summary>
            The system identifier of the DTD for this document type.
            </summary>
            -
            <remarks>
            Has value <c>obex-folder-listing.dtd</c>.
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Objects.ObexFolderListingParser.SystemIdentifierLoose">
            <summary>
            The system identifier of the DTD for the modified version of this document type.
            </summary>
            -
            <remarks>
            <para>Has value <c>obex-folder-listing loose.dtd</c>.
            </para>
            <para>See <see cref="P:Brecham.Obex.Objects.ObexXmlResolver.UseVerbatimFolderListingsDtd"/>
            for more information on why the modified DTD is required.
            </para>
            </remarks>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFolderListingParser.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the class with the specified <c>Stream</c>. 
            </summary>
            <param name="input">The stream containing the XML data to read.</param>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFolderListingParser.#ctor(System.IO.TextReader)">
            <summary>
            Initializes a new instance of the class with the specified <c>TextReader</c>. 
            </summary>
            <param name="input">The <c>TextReader</c> containing the XML data to read.</param>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFolderListingParser.GetAllItems_">
            <summary>
            Returns all the folder-items.  Simply calls
            <see cref="M:Brecham.Obex.Objects.FolderListingParser.GetNextItem"/>
            until the last item is returned, see its documentation for the 
            item types it can return and which exceptions it can throw.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFolderListingParser.GetAllItems">
            <summary>
            Returns all the folder-items, as a instance of the 
            <see cref="T:Brecham.Obex.Objects.ObexFolderListing"/>.
            </summary>
            <remarks>
            <para>Effectively calls
            <see cref="M:Brecham.Obex.Objects.ObexFolderListingParser.GetNextItem"/>
            until the last item is returned and returns them in the <c>ObexFolderListing</c>
            instance, see its documentation for the 
            item types it can return and which exceptions it can throw.
            </para>
            <para>
            Note that if <c>GetNextItem</c> is called before this method is called
            then any items it has returned will _not_ be included in this method’s
            result.
            </para>
            <para>See the <see cref="M:Brecham.Obex.Objects.ObexFolderListingParser.GetNextItem"/>
            documentation for the possible exceptions.</para>
            </remarks>
            <returns>
            An instance of <see cref="T:Brecham.Obex.Objects.ObexFolderListing"/> containing
            the items found in the parsing operation.
            </returns>
            <example>
            <code lang="Visual Basic">
            Private Sub DisplayFolderListing(sess As ObexClientSession)
               Dim xmlStrm As Stream = sess.Get(Nothing, ObexConstant.Type.FolderListing)
               Dim parser As New ObexFolderListingParser(xmlStrm)
               Dim listing As ObexFolderListing = parser.GetAllItems
               If (listing.HasParentFolder) Then Console.WriteLine("&lt;DIR&gt; ..")
               For Each folder As ObexFolderItem In listing.Folders
                  Console.WriteLine("&lt;DIR&gt; {0}", folder.Name)
               Next
               For Each file As ObexFileItem In listing.Files
                  Console.WriteLine("      {0}", file.Name)
               Next
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Brecham.Obex.Objects.ObexFolderListingParser.GetNextItem">
            <summary>
            Reads the next folder-listing item, as an instance of either
            <see cref="T:Brecham.Obex.Objects.ObexFileItem"/>,
            <see cref="T:Brecham.Obex.Objects.ObexFolderItem"/>, or 
            <see cref="T:Brecham.Obex.Objects.ObexParentFolderItem"/>,
            which are all subclasses of 
            <see cref="T:Brecham.Obex.Objects.ObexFolderListingItem"/>.
            </summary>
            <returns>
            An instance of the respective subclass of <c>ObexFolderListingItem</c> 
            holding the item&apos;s data.  Returns <c>null</c> (/<c>Nothing</c>) when the end of the 
            folder-listing document has been reached.  If called again after that 
            it throws the exception listed below.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            All the items have already been read by previous calls.
            </exception>
            <exception cref="T:System.Xml.XmlException">
            An error occurred while parsing the XML.
            </exception>
            <exception cref="T:System.Xml.Schema.XmlSchemaException">
            An error occurred while parsing the XML.
            </exception>
            <exception cref="T:System.NotSupportedException">
            On the Compact Framework (NETCF) this occurs when the XML document contains
            a DOCTYPE element.  
            See the Programmer's Guide and the <see 
            cref="P:Brecham.Obex.Objects.ObexFolderListingParser.StripDocType"/>
            property for more information.
            </exception>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFolderListingParser.Dtd">
            <summary>
            Returns a <see cref="T:System.IO.Stream"/> containing the DTD for the
            Folder-Listing object, from OBEX13.pdf section 9.1.4.1.  The DTD is 
            embedded in the assembly and thus no remote lookups are required.
            </summary>
            <remarks>
            <para>Note, if using the DTD with <c>System.Xml.XmlReader</c> for instance,
            then it is not necessary to access it directly through this method, instead
            have the <c>XmlReader</c> use the supplied XmlResolver
            (<see cref="T:Brecham.Obex.Objects.ObexXmlResolver"/>), or use the utility 
            method that returns an XmlReader configured in that way 
            e.g. <see cref="M:Brecham.Obex.Objects.ObexXmlUtilities.CreateXmlReader(System.IO.Stream)"/>.
            </para>
            <para>Note that the library contains two version of the DTD: the original 
            one from the specification, and a modified one to support listings formats
            as seen from various devices.
            This property returns 
            the original version of the DTD from the OBEX specification;
            the modified less strict one is available from the 
            <see cref="P:Brecham.Obex.Objects.ObexFolderListingParser.DtdLoose"/> property.
            For more information see <see cref="P:Brecham.Obex.Objects.ObexXmlResolver.UseVerbatimFolderListingsDtd"/>.
            </para>
            </remarks>
            <returns>A <see cref="T:System.IO.Stream"/> containing the DTD for the
            Folder-Listing object.</returns>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFolderListingParser.DtdLoose">
            <summary>
            Returns a <see cref="T:System.IO.Stream"/> containing the DTD for the
            Folder-Listing object, from OBEX13.pdf section 9.1.4.1.  The DTD is 
            embedded in the assembly and thus no remote lookups are required.
            </summary>
            -
            <remarks>
            <para>Note that the library contains two version of the DTD: the original 
            one from the specification, and a modified one to support listings formats
            as seen from various devices.
            This property returns 
            the modified less strict one; 
            the original version of the DTD from the OBEX specification; is available from the 
            <see cref="P:Brecham.Obex.Objects.ObexFolderListingParser.Dtd"/> property.
            For more information see <see cref="P:Brecham.Obex.Objects.ObexXmlResolver.UseVerbatimFolderListingsDtd"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFolderListingParser.IgnoreUnknownAttributeNames">
            <summary>
            Gets or sets whether undefined attributes on the folder-listing items 
            found while parsing will
            produce an error, or will simply be discarded.  By default an error is 
            produced and parsing is abandoned.
            </summary>
            <remarks>
            <para>
            The OBEX folder-listing document is defined formally by an XML DTD
            (Document Type Definition), see OBEX13.pdf section 9.1.4.1.  This defines
            what items types it can contain and the attributes that can exist on each.
            For instance, the <c>parent</c> item can contain no attributes, 
            and the <c>file</c> and <c>folder</c> items can contain attributes 
            including <c>Name</c>, <c>Type</c>, <c>Size</c>, <c>Owner</c> etc.
            </para>
            <para>
            Any valid folder-listing XML document must follow that DTD.  However in 
            testing it was found that not all devices follow the specification.  The 
            Nokia 6670, for instance, produces documents where the <c>folder</c>
            item can contain <c>mem-type</c> and <c>label</c> attributes.  Normally
            an XML parser would disallow such additions however the documents produced
            by such devices include an extra internal subset of the DTD and thus the 
            XML parser will accept such documents as legal.
            </para>
            <para>
            This folder-listing XML parser application (this class) will also validate 
            the attributes returned by the parser.
            This property controls whether we will produce an error for undefined attributes, 
            or instead ignore and discard them.
            </para>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFolderListingParser.IgnoreBadDateFormats">
            <summary>
            Gets or sets whether a bad date attribute on the folder-listing items 
            found while parsing will
            produce an error, or will simply be discarded.  By default an error is 
            produced and parsing is abandoned.
            </summary>
            -
            <remarks>
            <para>
            The OBEX folder-listing document is defined in OBEX13.pdf section 9.1.  
            This defines a XML DTD defining what items types a listing can contain,
            and the surrounding text defines the format of the attribute values.
            The format date attribute values is &#x201C;yyyymmddThhmmss[Z]&#x201D;.
            </para>
            <para>
            Any valid folder-listing XML document must follow that specification.  However in 
            testing it was found that not all devices follow the specification.  The 
            LG K800 phone, for instance, produces documents where the date attribute 
            can contain invalid values.  In the phone&#x2019;s root folder for instance 
            the &#x2019;modified&#x2019; date attribute contains value 
            &#x201C;19800000T-90000&#x201D;. 
            See the full content below.
            <code>
            &lt;?xml version="1.0"?&gt;
            &lt;!DOCTYPE folder-listing SYSTEM "obex-folder-listing.dtd"&gt;
            &lt;folder-listing version="1.0"&gt;
                    &lt;folder name="Images" modified="19800000T-90000"/&gt;
                    &lt;folder name="Sounds" modified="19800000T-90000"/&gt;
                    &lt;folder name="Videos" modified="19800000T-90000"/&gt;
                    &lt;folder name="Photos" modified="19800000T-90000"/&gt;
                    &lt;folder name="Music" modified="19800000T-90000"/&gt;
                    &lt;folder name="Text" modified="19800000T-90000"/&gt;
                    &lt;folder name="Others" modified="19800000T-90000"/&gt;
            &lt;/folder-listing&gt;
            </code>
            </para>
            <para>
            This folder-listing XML parser application (this class) will fail to 
            parse such an invalid date value.
            This property controls whether we will produce an error for such invalid 
            values or instead ignore and discard them.
            </para>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFolderListingParser.StripDocType">
            <summary>
            Controls whether the <c>DOCTYPE</c> element will be removed before parsing,
            this is necessary to allow the NETCF XmlTextReader to function.
            </summary>
            <remarks>
            <para>This defaults to enabled only on the Compact Framework version.</para>
            <para>See the Programmer's Guide for more information on why this is required.</para>
            <para>Note the stripping is only carried out if we are reading the
            document through a Stream; which is how it will be used when reading a
            Folder Listing from a peer device.</para>
            </remarks>
        </member>
        <member name="P:Brecham.Obex.Objects.ObexFolderListingParser.StripNullBytes">
            <summary>
            Controls whether null bytes will be removed, this allows such invalid
            documents to be parsed by the XmlTextReader class.
            </summary>
            <remarks>
            <para>This defaults to disabled on both platforms.</para>
            <para>See the Programmer's Guide for more information on why this is required.</para>
            <para>Note the stripping is only carried out if we are reading the
            document through a Stream; which is how it will be used when reading a
            Folder Listing from a peer device.</para>
            </remarks>
        </member>
        <member name="F:Brecham.Obex.Objects.ItemBuilder.ErrorMsgUnknownAttributeName">
            <exclude/>
        </member>
    </members>
</doc>
