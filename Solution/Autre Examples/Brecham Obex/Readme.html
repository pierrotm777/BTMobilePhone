<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <title>OBEX library &mdash; Readme</title>
    <!-- Use NDoc's stylesheet -->
    <link rel="stylesheet" type="text/css" href="MSDN.css" />
    <!-- But override the stupid margin//width -->
    <style type="text/css">
			body {margin: 15px; width: auto}
		</style>
    <style type="text/css">
			//code.inline { font-weight: bold; }
			code.sample { display: block; /* white-space: pre;*/ padding-left: 2em; }
			dt { font-weight: bold; }
			dd { margin-left: 1em; }
		</style>
</head>
<body style="background-color: #ffffff">
    <h1>
        OBEX library &mdash; Readme</h1>
    <p>
        12<sup>th</sup> October 2008 — release 1.7 (1.7.1012).</p>
    <!-- ___________________________________________________________ -->
    <h2>
        What&rsquo;s new</h2>
    <p>
        For the full list of changes in the current and previous versions see the <a href="./Changes.html">Changes</a> document.&nbsp; In brief the changes in the core library in this version include</p>
    <ul>
        <li>The listings produced by some SonyEricsson and LG phones include a user-perm (permissions)
            attribute with an empty value.&nbsp; This is disallowed by the Folder-Listings DTD
            in the OBEX specification, and thus the .NET XmlReader fails on reading that attribute,
            with &#x201C;The 'user-perm' attribute has an invalid value according to its data type.&#x201D;.&nbsp;
            We have included a modified DTD in the library which permits the emtpy string,
            and the Folder-Listing parser class now uses it by default.</li>
        <li>Previously when reading a Folder-Listing, the operation generally was completed by sending
            an ABORT pdu to the server. &nbsp;Now a normal GET close is carried out.&nbsp; The
            ABORT pdu causes no problems as far as I know but thought I&#x2019;d fix it anyway in case
            the ABORT appears to server logs and might confuse someone. This occurred due to
            our workaround for the bug in listings produced by Broadcom/Widcomm.</li>
        <li>Added an Authentication class which contains some method to create an parse the various
            OBEX Authentication headers, and also to do the secure hash of the password.&nbsp; These
            methods are currently marked as: &#x201C;Prelimary code, may change or disappear in later
            versions.&#x201D; Please give me your feedback!</li>
    </ul>
    <p>
        Changes in the previous version (1.6) include:</p>
    <ul>
        <li>Add option <code>IgnoreBadDateFormats</code> to ObexFolderListingParser, to allow
            it to continue even when the server provides invalid folder-listing content.&nbsp;
            For instance the LG K800 phone sometimes produces date values like <code>modified="19800000T-90000"</code>
            a negative time!&nbsp; See the Programmer’s Guide for more information. </li>
        <li>Added ObexClientSession.PutFile which takes a pathname parameter of the file to
            send. </li>
        <li>Add a <code>Headers</code> property to the ObexResponseException which lists the
            headers received along with the error response. (Note that the headers are currently
            discarded if the exception is runtime-serialized). &nbsp;</li>
    </ul>
    <p>
        These were a few fixes and improvements to the sample programs in that release also.<span style="background-color: #ffff66"></span></p>
    <!-- ___________________________________________________________ -->
    <h2>
        Features</h2>
    <p>
        The library provides very broad client-side OBEX support, providing not just the
        &lsquo;Put&rsquo; operation that most libraries and applications support, but also
        the complete set of operations: Connect, Put, Get, SetPath, Delete, and Abort. This
        is accessed through a session based interface. All errors communicating to the peer
        OBEX server are exposed to the calling application.
    </p>
    <p>
        As well as the &lsquo;on-the-wire&rsquo; protocol support there is also broad support
        for the objects defined in the OBEX specification, for instance the Folder Listing
        XML documents as used by the Folder-Browsing service. A full parser, returning an
        array of folder and file objects, is included
    </p>
    <p>
        The library also provides access to its lower-level PDU (packet) creation and parsing
        facilities, enabling third-party implementation of any required features, for instance
        server-side operation, and perhaps even reliable-session support.
    </p>
    <p>
        The library, its class documentation in both compiled HTML Help, and in raw XML
        for Intellisense, and a <a href="./Programmers guide.html">Programmer&rsquo;s Guide</a>
        are included.
    </p>
    <p>
        Assemblies for both the FXv2 desktop and Compact Framework versions 1 and 2 are supplied.
    </p>
    <p>
        Included sample code contains examples in both C# and VB.NET, showing how to use
        Put, Get, SetPath, and Folder Listings operations. They include examples of asynchronous
        usage, along with progress bar updating. Most use the TransportConnection library
        to form the connection to the OBEX server.&nbsp; Some however manually create the
        connection.
    </p>
    <!-- ___________________________________________________________ -->
    <!--<h2>License</h2>
		<p>
			Copyright me, free for any use.
		</p>-->
    <!-- ___________________________________________________________ -->
    <h2>
        Samples
    </h2>
    <p>
        In summary, the following samples are included</p>
    <!--p-->
        <table border="1" style="border-collapse: collapse">
            <tr>
                <td style="width: 100px;">
                    <b>Name</b></td>
                <td style="width: 47px">
                    <b>Lang.</b></td>
                <td>
                    <b>Format</b></td>
                <td style="width: 351px;">
                    <b>Features</b></td>
                <td style="width: 351px;">
                    <b>Background threading method</b></td>
            </tr>
            <tr>
                <td style="width: 100px;">
                PutGuiVb2</td>
                <td style="width: 47px">
                VB.NET</td>
                <td>
                WinForms</td>
                <td style="width: 351px;">
                PUT</td>
                <td style="width: 351px;">
                BackgroundWorker</td>
            </tr>
            <tr>
                <td style="width: 100px;">
                VbPutSample</td>
                <td style="width: 47px">
                VB.NET</td>
                <td>
                Command-line</td>
                <td style="width: 351px;">
                PUT</td>
                <td style="width: 351px;">
                None</td>
            </tr>
            <tr>
                <td style="width: 100px; height: 17px;">
                FolderExplorer2</td>
                <td style="width: 47px; height: 17px">
                VB.NET</td>
                <td style="height: 17px">
                WinForms</td>
                <td style="width: 351px; height: 17px;">
                Explorer style; FolderListings, GET</td>
                <td style="width: 351px; height: 17px;">
                BackgroundWorker</td>
            </tr>
            <tr>
                <td style="width: 100px;">
                GetFirstListedFile</td>
                <td style="width: 47px">
                VB.NET</td>
                <td>
                Command-line</td>
                <td style="width: 351px;">
                FolderListings, GET</td>
                <td style="width: 351px;">
                None</td>
            </tr>
            <!--  xx  -->
            <tr>
                <td style="width: 100px;">
                    PutGUI</td>
                <td style="width: 47px">
                    C#</td>
                <td>
                    WinForms</td>
                <td style="width: 351px;">
                    PUT</td>
                <td style="width: 351px;">
                    delegate.BeginInvoke and progress decorator Stream</td>
            </tr>
            <tr>
                <td style="width: 100px;">
                    PutCmdline</td>
                <td style="width: 47px">
                    C#</td>
                <td>
                    Command-line</td>
                <td style="width: 351px;">
                    PUT</td>
                <td style="width: 351px;">
                    None</td>
            </tr>
            <tr>
                <td style="width: 100px;">
                    GetFolderListings</td>
                <td style="width: 47px">
                    C#</td>
                <td>
                    Console</td>
                <td style="width: 351px;">
                    FolderListings, GET, PUT.</td>
                <td style="width: 351px;">
                    None</td>
            </tr>
        </table>
    <!--/p-->
    <h3>
        VB.NET</h3>
    <p>
        For VB.NET four samples are included. The VbPutSample is a simple command-line
        Put client, PutGuiVb2 is a simple GUI Put client, GetFirstListedFile is a command-line
        program that will walk through the peer&#x2019;s folders and download the first
        file it finds listed, finally FolderExplorer2 is a GUI Windows Explorer style application
        that lists the folders and files on the peer allow the user to navigate through
        them. In a previous release the Visual Basic samples were created and built by hand, now the samples have been created with Visual Studio with the
        forms created in the Forms Designer etc.</p>
    <p style="text-align: center">
        <img style="margin: 10px" alt="Screenshot of FolderExplorerVb sample" title="Screenshot of FolderExplorerVb sample"
            src="FolderExplorerVb (Custom).PNG" />
    </p>
    <p>
        Both PutGuiVb2 and FolderExplorer2 display a progress bar as they do the upload
        / download. They use a Background Worker component in which the content is manually
        copied from the source to the destination stream, in the former application, from
        the file stream <i>to</i> the <code>ObexPutStream</code>, and in the latter from the <code>
            ObexGetStream</code> <i>to</i> the list boxes. Each time round they update the
        progress status, and check for user cancelling.
    </p>
    <p>
        The Length of the object in the GET operation is accessed through the headers in
        the <code>ObexGetStream</code>&#x2019;s new<i></i> <code>ResponseHeaders</code>
        property, and is used to calculate the percentage-completed progress there. However
        the inclusion of such a header is optional and thus if the server has not provided
        a Length header then a pseudo-progress bar is displayed.</p>
    <h3>
        C#</h3>
    <p>
        For C#, two PUT clients are
        included, one Windows Forms and one command-line. The command-line application prints
        usage information when run with no command-line arguments. The UI client shows asynchronous
        usage, and progress bar updating as the transfer proceeds. It uses the rather complex method of using <code>delegate</code>&#x2019;s
        <code>BeginInvoke</code> feature, along with a &#x2018;decorator&#x2019; stream to
        measure the progress of the download, with a <code>Timer</code> component using its result to update
        a progress bar.
    </p>
    <p style="text-align: center">
        <img style="margin: 10px" alt="Screenshot of PutGUI sample" title="Screenshot of PutGUI sample"
            src="PutGUI (Custom).png" />
        <img style="margin: 10px" alt="Screenshot of PutCmdline sample" title="Screenshot of PutCmdline sample"
            src="PutCmdline (Custom).png" />
    </p>
    <p>
        There&rsquo;s also a console-based menu-driven GET client, which, although it is
        called &lsquo;GetFolderListing&rsquo;, supports all Get operations, and can connect
        to both the &lsquo;Folder-Browsing&rsquo; and &lsquo;Inbox&rsquo; services. It can
        display the current folder&rsquo;s folder listing, displaying its content in a similar
        layout to the Windows&rsquo; DIR command; except of course since the <code class="inline">
            parent-folder</code> item does not define any attributes it cannot display the
        current folder&rsquo;s last modified time. It can also do a Put operation.</p>
    <p>
        It saves any downloads to the current folder with a name created from the current
        operation, for instance a raw folder-listing object (command "L") is saved to a
        filename of <code>&lt;folderName&gt;.xml</code>, with &ldquo;Root.xml&rsquo; used
        for the default folder. Note that the download is also currently displayed on the
        screen as it is received, for binary files the text conversion will fail and the
        displaying will cease, and continue only to display dots as the download proceeds.
        Its source code is also now included.
    </p>
    <p style="text-align: center">
        <img style="margin: 10px" alt="Screenshot of GetFolderListing sample" title="Screenshot of GetFolderListing sample"
            src="GetFolderListing (Custom).PNG" />
    </p>
    <h3>
        Building</h3>
    <p>
        The source code for all the sample projects is included. To compile them
        from the command-line one could use the following command (on one line). 
    </p>
    <p>
        <code class="sample">C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\MSBuild "Brecham
            Obex\Samples\Samples.sln" /p:Configuration=Release </code>
    </p>
    <p>
        Otherwise, the solutions can be loaded in Visual Studio and built there.</p>
    <p>
        The debug configuration of some of the samples includes NUnit tests, so as 
        configured that library is required for debug compilation. To get the 
        build to work, one way would thus be to install the NUnit tool from 
        <a href="http://www.nunit.org/">http://www.nunit.org/</a>, otherwise, the tests 
        are all defined within <code>#if NUNIT ... #endif</code> blocks; and currently
        only two of the projects contains unit-tests: TransportConnection and GetFolderListings.
        So you could go to the properties pages of those samples and remove "NUNIT" from
        the Conditional compilation symbols field in the debug build configurations.</p>
    <!-- ___________________________________________________________ -->
    <h2>
        Compact Framework</h2>
    <p>
        The library and samples compiled for CF v2.0 are provided in the NETCF folder, and
        for CF v1.0 in the NETCFv1 folder. Necessary
        changes were made to the source to have it compile against the CF; the changes
        to the OBEX library itself were minor: loosening of the strict ASCII string to Byte
        Sequence conversion due to the non-existence of fallback exception modes in <span
            style="font-size: 100%; color: #000066; font-family: Monospace, Courier New, Courier">
            System.Text.</span><code>Encoding</code>, removal of some assembly level attributes, and latterly,
        removal of some logging code, and the implementation of the DOCTYPE stripping
        as discussed above.&nbsp; The library is also supplied compiled for CF
        v1.0 and one sample for it is also included.</p>
    <p>
        <img src="NETCF PutGuiVb (Custom).PNG" style="float: right; margin: 0px 10px 10px" 
            alt="Screenshot of NETCF PutGuiVb sample"/>
        Early version of the library did not fully work on the  NETCF unfortunately, and 
        I was no longer happy with releasing the core library for a platform on which it hadn't
        been fully tested. Running the ~600 unit-tests from the NETCF assembly on the desktop
        CLR obviously not being up to the job, as of course it used the desktop
        Framework Class Library, so I set about
        finding a solution to that. I thus created an application to run all of my NUnit
        unit-tests on a PocketPC device. Now, I haven't yet got any code
        coverage solution there, but all of the applicable
        tests run and pass, so I'm much
        happier now. The main thing highlighted by running the tests was the DOCTYPE issue in the Folder
        Listing parser.&nbsp; The samples have also all
        been tested on real Windows Mobile devices.</p>
    <p>
        Four samples are included (thought only one for NETCFv1).&nbsp; There are conversions of the PutGUI C#, PutGuiVb2,
        and FolderExplorer programs from the desktop, there is also a version of FolderExplorer
        for Smartphone.&nbsp;
        In all cases the projects were created from scratch within Visual Studio with the Forms
        laid out there and the communications code copied from their desktop equivalents.&nbsp;
        In all cases of course the background threading functionality had to be created
        from scratch, manual implementations of the BackgroundWorker component and the delegate.BeginInvoke
        being provided respectively.&nbsp; There is also a new simple GET sample, GetUi,
        which allow downloading of files, with their name and optionally media type supplied
        manually; this sample was of most use before the DOCTYPE stripping work was done
        for the folder-listing parser.</p>
    <!-- ___________________________________________________________ -->
    <h2>
        On the WebRequest Pattern</h2>
    <p>
        The library does not implement the <code>WebRequest</code> pattern. This pattern,
        as generally used in its <code>HttpWebRequest</code> form, is most suited to that
        protocol, which is of course session-less. FTP and OBEX are session based, so on
        the same transport connection they can for instance connect, with authentication,
        perhaps then change directory, list its contents, then upload one file, and download
        another. To fit the WebRequest Pattern there has to be lots of magic behind the
        scenes to make a second <code>FtpWebRequest</code> instance use the connection that
        a previous instance finished using some time before... This also makes a very odd
        programming experience for the consuming developer, so, at the moment there&#x2019;s no
        such implementation, as my view that the library&#x2019;s session-based API is very much
        easier to use.
    </p>
    <p>
        The sample TransportConnection library includes a class <code>UriObexSessionConnection</code>
        which takes a URI of a similar format to that used by 32feet.NET&#x2019;s <code>ObexWebRequest</code>
        class, and forms a connection to the specified device and OBEX service, this can
        be used if converting your code between the two libraries.
    </p>
    <!-- ___________________________________________________________ -->
    <h2>
        Support</h2>
    <p>
        Support is available through the <a href="http://www.32feet.net">32feet.NET</a>
        website, where the Brecham.Obex support forum is provided for that purpose. New
        releases will be also made available there.
    </p>
    <!-- ___________________________________________________________ -->
    <h2>
    </h2>
    <p>
        Andy Hume
    </p>
</body>
</html>
