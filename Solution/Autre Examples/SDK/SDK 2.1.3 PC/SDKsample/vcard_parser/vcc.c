#ifndef lint
static char const 
yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
#endif
#include <stdlib.h>
#include <crtdbg.h>
#include <stdarg.h>
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYLEX yylex()
#define YYEMPTY -1
#define yyclearin (yychar=(YYEMPTY))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING() (yyerrflag!=0)
static int yygrowstack();
#define YYPREFIX "yy"
////#line 1 "vcc.y"


/* include message and note */

/***************************************************************************

(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             

Business Machines Corporation and Siemens Rolm Communications Inc.             

                                                                               

For purposes of this license notice, the term Licensors shall mean,            

collectively, Apple Computer, Inc., AT&T Corp., International                  

Business Machines Corporation and Siemens Rolm Communications Inc.             

The term Licensor shall mean any of the Licensors.                             

                                                                               

Subject to acceptance of the following conditions, permission is hereby        

granted by Licensors without the need for written agreement and without        

license or royalty fees, to use, copy, modify and distribute this              

software for any purpose.                                                      

                                                                               

The above copyright notice and the following four paragraphs must be           

reproduced in all copies of this software and any software including           

this software.                                                                 

                                                                               

THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       

ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       

MODIFICATIONS.                                                                 

                                                                               

IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              

INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         

OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         

DAMAGE.                                                                        

                                                                               

EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       

INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            

IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             

PURPOSE.                                                                       



The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         

disclosure by the government are subject to restrictions set forth in          

DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         



***************************************************************************/



/*

 * src: vcc.c

 * doc: Parser for vCard and vCalendar. Note that this code is

 * generated by a yacc parser generator. Generally it should not

 * be edited by hand. The real source is vcc.y. The //#line directives

 * can be commented out here to make it easier to trace through

 * in a debugger. However, if a bug is found it should 

 * be fixed in vcc.y and this file regenerated.

 */





/* debugging utilities */

#if __DEBUG

#define DBG_(x) myprintf x

#else

#define DBG_(x)

#endif



/****  External Functions  ****/



/* assign local name to parser variables and functions so that

   we can use more than one yacc based parser.

*/



#define yyparse mime_parse

#define yylex mime_lex

#define yyerror mime_error

#define yychar mime_char

/* #define p_yyval p_mime_val */

#undef yyval

#define yyval mime_yyval

/* #define p_yylval p_mime_lval */

#undef yylval

#define yylval mime_yylval

#define yydebug mime_debug

#define yynerrs mime_nerrs

#define yyerrflag mime_errflag

#define yyss mime_ss

#define yyssp mime_ssp

#define yyvs mime_vs

#define yyvsp mime_vsp

#define yylhs mime_lhs

#define yylen mime_len

#define yydefred mime_defred

#define yydgoto mime_dgoto

#define yysindex mime_sindex

#define yyrindex mime_rindex

#define yygindex mime_gindex

#define yytable mime_table

#define yycheck mime_check

#define yyname mime_name

#define yyrule mime_rule

#define YYPREFIX "mime_"



 

#ifndef _NO_LINE_FOLDING

#define _SUPPORT_LINE_FOLDING 1

#endif



/* undef below if compile with MFC */

/* #define INCLUDEMFC 1 */



#if defined(WIN32) || defined(_WIN32)

#ifdef INCLUDEMFC

#include <afx.h>

#endif

#endif



#include <string.h>

#ifndef __MWERKS__

#include <malloc.h>

#endif

#include <stdio.h>

#include <stdlib.h>

#include <ctype.h>

#include "vcc.h"

//#include "global.h"//temp test


/****  Types, Constants  ****/



#define YYDEBUG		0	/* 1 to compile in some debugging code */

#define MAXTOKEN	1024	/* maximum token (line) length */

#define YYSTACKSIZE 	50	/* ~unref ?
*/
#define MAXLEVEL	10	/* max # of nested objects parseable */

				/* (includes outermost) */





/****  Global Variables  ****/

int mime_lineNum, mime_numErrors; /* yyerror() can use these */

static VObject* vObjList;

static VObject *curProp;

static VObject *curObj;

static VObject* ObjStack[MAXLEVEL];

static int ObjStackTop;





/* A helpful utility for the rest of the app. */

#if __CPLUSPLUS__

extern "C" {

#endif



    extern void Parse_Debug(const char *s);

    extern void yyerror(char *s);



#if __CPLUSPLUS__

    };

#endif


char tmp[1024];
void myprintf (char * fmt, ...)
{
    va_list arglist;
	va_start(arglist, fmt);
	vsprintf(tmp, fmt, arglist);
	_RPT0(_CRT_WARN, tmp);
}

int yyparse();

/***************************************************************************************************/

enum LexMode {

	L_BASE64,

	L_NORMAL,

	L_QUOTED_PRINTABLE,

	L_VBODY,

	L_VCARD,

	L_VCAL,

	L_VEVENT,

	L_VMESSAGE,

	L_VMSGENV,

	L_VNOTE,

	L_VALUES,

	L_VTODO,

};



/****  Private Forward Declarations  ****/

static int pushVObject(const char *prop);

static VObject* popVObject();

static char* lexDataFromBase64();

static void lexPopMode(int top);

static int lexWithinMode(enum LexMode mode);

static void lexPushMode(enum LexMode mode);

static void enterProps(const char *s);

static void enterAttr(const char *s1, const char *s2);

static void enterValues(const char *value);

static void mime_error_(char *s);



////#line 183 "vcc.y"
typedef union {

    char *str;

    VObject *vobj;

    } YYSTYPE;
////#line 199 "y.tab.c"
#define YYERRCODE 256
#define EQ 257
#define COLON 258
#define DOT 259
#define SEMICOLON 260
#define SPACE 261
#define HTAB 262
#define LINESEP 263
#define NEWLINE 264
#define BEGIN_VCARD 265
#define END_VCARD 266
#define BEGIN_VNOTE 267
#define END_VNOTE 268
#define BEGIN_VMESSAGE 269
#define END_VMESSAGE 270
#define BEGIN_VCAL 271
#define END_VCAL 272
#define BEGIN_VEVENT 273
#define END_VEVENT 274
#define BEGIN_VTODO 275
#define END_VTODO 276
#define BEGIN_VBODY 277
#define END_VBODY 278
#define BEGIN_VMSGENV 279
#define END_VMSGENV 280
#define ID 281
#define STRING 282
const short yylhs[] = {                                        -1,
    0,   11,   10,   10,    9,    9,    9,    9,   13,    6,
   14,   14,   14,   16,    7,   15,   15,   17,    8,   18,
    5,   19,    3,   20,    3,   12,   12,   24,   21,   21,
   26,   22,   22,   25,   25,   27,   28,   28,    1,   29,
   23,   23,    2,    2,   31,    4,   32,    4,   30,   30,
   33,   33,   33,   36,   34,   37,   34,   38,   35,   39,
   35,
};
const short yylen[] = {                                         2,
    1,    0,    3,    1,    1,    1,    1,    1,    0,    6,
    2,    1,    0,    0,    4,    2,    2,    0,    4,    0,
    4,    0,    4,    0,    3,    2,    1,    0,    5,    1,
    0,    3,    1,    2,    1,    2,    1,    3,    1,    0,
    4,    1,    1,    0,    0,    4,    0,    3,    2,    1,
    1,    1,    1,    0,    4,    0,    3,    0,    4,    0,
    3,
};
const short yydefred[] = {                                      0,
    0,   20,    9,    0,    0,    5,    6,    7,    8,    0,
    1,    0,    0,    0,    0,    0,    0,    0,   30,   39,
    0,    0,    0,    0,   25,    0,    0,    0,    0,   53,
    0,    0,   51,   52,   48,    3,    0,   23,   26,   28,
   21,    0,    0,    0,    0,    0,    0,   46,   49,    0,
   32,    0,    0,   11,   14,    0,    0,   57,    0,   61,
    0,   36,   34,   43,    0,    0,    0,   10,   55,   59,
    0,   40,   29,    0,    0,   38,    0,   18,   16,   17,
   15,   41,    0,    0,   19,
};
const short yydgoto[] = {                                       5,
   21,   65,   42,    7,    8,    9,   56,   80,   10,   11,
   18,   30,   15,   43,   75,   67,   83,   14,   12,   13,
   23,   24,   66,   53,   51,   37,   52,   62,   77,   31,
   16,   17,   32,   33,   34,   44,   45,   46,   47,
};
const short yysindex[] = {                                   -209,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, -244, -256, -244, -244, -251, -254, -209,    0,    0,
    0, -247, -244, -233,    0, -232, -226,    0,    0,    0,
 -225, -251,    0,    0,    0,    0, -214,    0,    0,    0,
    0, -226, -211, -244, -221, -244, -207,    0,    0, -208,
    0, -214, -210,    0,    0, -200, -199,    0, -202,    0,
 -181,    0,    0,    0, -183, -185, -226,    0,    0,    0,
 -208,    0,    0, -234, -198,    0, -210,    0,    0,    0,
    0,    0, -244, -197,    0,
};
const short yyrindex[] = {                                      0,
 -250,    0,    0, -252,    0,    0,    0,    0,    0,    1,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 -201,    0, -224,    0,    0,    0, -196, -248, -241,    0,
    0, -193,    0,    0,    0,    0,    0,    0,    0,    0,
    0, -216,    0,    0,    0,    0,    0,    0,    0,    0,
    0, -178, -246,    0,    0,    0,    0,    0,    0,    0,
 -194,    0,    0,    0, -179,    0, -212,    0,    0,    0,
    0,    0,    0,    0,    0,    0, -246,    0,    0,    0,
    0,    0,    0,    0,    0,
};
const short yygindex[] = {                                      0,
  -43,    0,    9,    0,    0,    0,   11,    0,    0,   68,
    0,  -12,    0,  -29,    0,    0,    0,    0,    0,    0,
    0,    0,   10,    0,   36,    0,    0,    0,    0,   57,
    0,    0,    0,    0,    0,    0,    0,    0,    0,
};
#define YYTABLESIZE 272
const short yytable[] = {                                      22,
    4,   26,   27,   45,   19,   22,   61,   54,    6,   25,
   39,   19,   54,   44,   58,   24,   44,   35,   38,   47,
   45,   28,   45,   29,   40,   56,    6,   76,   45,   20,
   22,   57,   54,   59,   60,   41,   20,   74,    1,   58,
   27,   27,   78,   27,   55,   50,   48,   27,   27,   27,
   27,   27,   58,   27,   27,    1,   33,    2,   31,    3,
   12,    4,   12,   37,   13,   37,   13,   55,   60,   68,
   84,   64,   20,   70,   69,   71,   72,   73,   50,   35,
   85,   81,   13,   42,   79,   36,   82,   63,   49,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    2,    0,    2,    0,    2,
    0,    2,
};
const short yycheck[] = {                                      12,
    0,   14,   15,  256,  256,  256,   50,  256,    0,  266,
   23,  256,   42,  260,  256,  266,  263,  272,  266,  272,
  273,  273,  275,  275,  258,  274,   18,   71,  281,  281,
  281,   44,  281,   46,  276,  268,  281,   67,  265,  281,
  265,  266,  277,  268,  279,  260,  272,  272,  273,  274,
  275,  276,  274,  278,  279,  265,  258,  267,  260,  269,
  277,  271,  279,  258,  277,  260,  279,  279,  276,  270,
   83,  282,  281,  276,  274,  257,  260,  263,  272,  258,
  278,  280,  279,  263,   74,   18,   77,   52,   32,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  265,   -1,  267,   -1,  269,
   -1,  271,
};
#define YYFINAL 5
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 282
#if YYDEBUG
const char * const yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"EQ","COLON","DOT","SEMICOLON",
"SPACE","HTAB","LINESEP","NEWLINE","BEGIN_VCARD","END_VCARD","BEGIN_VNOTE",
"END_VNOTE","BEGIN_VMESSAGE","END_VMESSAGE","BEGIN_VCAL","END_VCAL",
"BEGIN_VEVENT","END_VEVENT","BEGIN_VTODO","END_VTODO","BEGIN_VBODY","END_VBODY",
"BEGIN_VMSGENV","END_VMSGENV","ID","STRING",
};
const char * const yyrule[] = {
"$accept : mime",
"mime : vobjects",
"$$1 :",
"vobjects : vobject $$1 vobjects",
"vobjects : vobject",
"vobject : vcard",
"vobject : vcal",
"vobject : vnote",
"vobject : vmessage",
"$$2 :",
"vmessage : BEGIN_VMESSAGE $$2 items vcards vmsgenv END_VMESSAGE",
"vcards : vcard vcards",
"vcards : vcard",
"vcards :",
"$$3 :",
"vmsgenv : BEGIN_VMSGENV $$3 vmsgenvbody END_VMSGENV",
"vmsgenvbody : vcards vmsgenv",
"vmsgenvbody : vcards vbody",
"$$4 :",
"vbody : BEGIN_VBODY $$4 items END_VBODY",
"$$5 :",
"vnote : BEGIN_VNOTE $$5 items END_VNOTE",
"$$6 :",
"vcard : BEGIN_VCARD $$6 items END_VCARD",
"$$7 :",
"vcard : BEGIN_VCARD $$7 END_VCARD",
"items : item items",
"items : item",
"$$8 :",
"item : prop COLON $$8 values LINESEP",
"item : error",
"$$9 :",
"prop : name $$9 attr_params",
"prop : name",
"attr_params : attr_param attr_params",
"attr_params : attr_param",
"attr_param : SEMICOLON attr",
"attr : name",
"attr : name EQ name",
"name : ID",
"$$10 :",
"values : value SEMICOLON $$10 values",
"values : value",
"value : STRING",
"value :",
"$$11 :",
"vcal : BEGIN_VCAL $$11 calitems END_VCAL",
"$$12 :",
"vcal : BEGIN_VCAL $$12 END_VCAL",
"calitems : calitem calitems",
"calitems : calitem",
"calitem : eventitem",
"calitem : todoitem",
"calitem : items",
"$$13 :",
"eventitem : BEGIN_VEVENT $$13 items END_VEVENT",
"$$14 :",
"eventitem : BEGIN_VEVENT $$14 END_VEVENT",
"$$15 :",
"todoitem : BEGIN_VTODO $$15 items END_VTODO",
"$$16 :",
"todoitem : BEGIN_VTODO $$16 END_VTODO",
};
#endif
#if YYDEBUG
#include <stdio.h>
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH 10000
#endif
#endif
#define YYINITSTACKSIZE 200
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short *yyss;
short *yysslim;
YYSTYPE *yyvs;
int yystacksize;
////#line 462 "vcc.y"



int* g_yys = NULL;
int g_yys_count = 0;

/*/////////////////////////////////////////////////////////////////////////*/

static int pushVObject(const char *prop)

{

    VObject *newObj;

    if (ObjStackTop == MAXLEVEL)

		return FALSE;

    if (curObj) {

        newObj = addProp(curObj,prop);

        curObj = newObj;

	}

    else

		curObj = newVObject(prop);

    ObjStack[++ObjStackTop] = curObj;
	

    return TRUE;

}





/*/////////////////////////////////////////////////////////////////////////*/

/* This pops the recently built vCard off the stack and returns it. */

static VObject* popVObject()

{

    VObject *oldObj;

    if (ObjStackTop < 0) {

		yyerror("pop on empty Object Stack\n");

		return 0;

	}

    oldObj = curObj;

    curObj = ObjStack[ObjStackTop--];

	

    return oldObj;

}





static void enterValues(const char *value)

{

    if (fieldedProp && *fieldedProp) {

		if (value) {

			addPropValue(curProp,*fieldedProp,value);

		}

		/* else this field is empty, advance to next field */

		fieldedProp++;

	}

    else {

		if (value) {

			setVObjectUStringZValue_(curProp,fakeUnicode(value,0));

		}

	}

    deleteStr(value);

}



static void enterProps(const char *s)

{

    curProp = addGroup(curObj,s);

    deleteStr(s);

}



static void enterAttr(const char *s1, const char *s2)

{

    const char *p1, *p2;

    p1 = lookupProp_(s1);

    if (s2) {

		VObject *a;

		p2 = lookupProp_(s2);

		a = addProp(curProp,p1);

		setVObjectStringZValue(a,p2);

	}

    else

		addProp(curProp,p1);

    if (stricmp(p1,VCBase64Prop) == 0 || (s2 && stricmp(p2,VCBase64Prop)==0))

		lexPushMode(L_BASE64);

    else if (stricmp(p1,VCQuotedPrintableProp) == 0

		|| (s2 && stricmp(p2,VCQuotedPrintableProp)==0))

		lexPushMode(L_QUOTED_PRINTABLE);

    deleteStr(s1); deleteStr(s2);

}





#define MAX_LEX_LOOKAHEAD_0 32

#define MAX_LEX_LOOKAHEAD 64

#define MAX_LEX_MODE_STACK_SIZE 10

#define LEXMODE() (lexBuf.lexModeStack[lexBuf.lexModeStackTop])



struct LexBuf {

	/* input */

#ifdef INCLUDEMFC

    CFile *inputFile;

#else

    FILE *inputFile;

#endif

    char *inputString;

    unsigned long curPos;

    unsigned long inputLen;

	/* lookahead buffer */

	/*   -- lookahead buffer is short instead of char so that EOF

	/      can be represented correctly.

	*/

    unsigned long len;

    short buf[MAX_LEX_LOOKAHEAD];

    unsigned long getPtr;

	/* context stack */

    unsigned long lexModeStackTop;

    enum LexMode lexModeStack[MAX_LEX_MODE_STACK_SIZE];

	/* token buffer */

    unsigned long maxToken;

    char *strs;

    unsigned long strsLen;

} lexBuf;



static void lexPushMode(enum LexMode mode)

{

    if (lexBuf.lexModeStackTop == (MAX_LEX_MODE_STACK_SIZE-1))

		yyerror("lexical context stack overflow");

    else {

		lexBuf.lexModeStack[++lexBuf.lexModeStackTop] = mode;

	}

}



static void lexPopMode(int top)

{

	/*	special case of pop for ease of error recovery -- this

		version will never underflow 

	*/

    if (top)

		lexBuf.lexModeStackTop = 0;

    else

		if (lexBuf.lexModeStackTop > 0) lexBuf.lexModeStackTop--;

}



static int lexWithinMode(enum LexMode mode) {

    unsigned long i;

    for (i=0;i<lexBuf.lexModeStackTop;i++)

	if (mode == lexBuf.lexModeStack[i]) return 1;

    return 0;

    }



static char lexGetc_()

{

    /* get next char from input, no buffering. */

    if (lexBuf.curPos == lexBuf.inputLen)

		return EOF;

    else if (lexBuf.inputString)

		return *(lexBuf.inputString + lexBuf.curPos++);

    else {

#ifdef INCLUDEMFC

		char result;

		return lexBuf.inputFile->Read(&result, 1) == 1 ? result : EOF;

#else

		return fgetc(lexBuf.inputFile);

#endif

	}

}



static int lexGeta()

{

    ++lexBuf.len;

    return (lexBuf.buf[lexBuf.getPtr] = lexGetc_());

}



static int lexGeta_(int i)    

{

    ++lexBuf.len;

    return (lexBuf.buf[(lexBuf.getPtr+i)%MAX_LEX_LOOKAHEAD] = lexGetc_());

}



static void lexSkipLookahead() 

{

    if (lexBuf.len > 0 && lexBuf.buf[lexBuf.getPtr]!=EOF) {

		/* don't skip EOF. */

        lexBuf.getPtr = (lexBuf.getPtr + 1) % MAX_LEX_LOOKAHEAD;

		lexBuf.len--;

	}

}



static int lexLookahead() 

{

    int c = (lexBuf.len)?

		lexBuf.buf[lexBuf.getPtr]:

		lexGeta();

    /* do the \r\n -> \n or \r -> \n translation here */

    if (c == '\r') {

		int a = (lexBuf.len>1)?

			lexBuf.buf[(lexBuf.getPtr+1)%MAX_LEX_LOOKAHEAD]:

		lexGeta_(1);

		if (a == '\n') {

			lexSkipLookahead();

		}

		lexBuf.buf[lexBuf.getPtr] = c = '\n';

	}

    else if (c == '\n') {

		int a = (lexBuf.len>1)?

			lexBuf.buf[lexBuf.getPtr+1]:

		lexGeta_(1);

		if (a == '\r') {

			lexSkipLookahead();

		}

		lexBuf.buf[lexBuf.getPtr] = '\n';

	}

    return c;

}



static int lexGetc() {

    int c = lexLookahead();

    if (lexBuf.len > 0 && lexBuf.buf[lexBuf.getPtr]!=EOF) {

		/* EOF will remain in lookahead buffer */

        lexBuf.getPtr = (lexBuf.getPtr + 1) % MAX_LEX_LOOKAHEAD;

		lexBuf.len--;

	}

    return c;

}



static void lexSkipLookaheadWord() {

    if (lexBuf.strsLen <= lexBuf.len) {

		lexBuf.len -= lexBuf.strsLen;

		lexBuf.getPtr = (lexBuf.getPtr + lexBuf.strsLen) % MAX_LEX_LOOKAHEAD;

	}

}



static void lexClearToken()

{

    lexBuf.strsLen = 0;

}



static void lexAppendc(int c)

{

    lexBuf.strs[lexBuf.strsLen] = c;

    /* append up to zero termination */

    if (c == 0) return;

    lexBuf.strsLen++;

    if (lexBuf.strsLen >= lexBuf.maxToken) {

		/* double the token string size */

		lexBuf.maxToken <<= 1;

		lexBuf.strs = (char*) realloc(lexBuf.strs,(size_t)lexBuf.maxToken);

	}

}



static char* lexStr() {

    return dupStr(lexBuf.strs,(size_t)lexBuf.strsLen+1);

}



static void lexSkipWhite() {

    int c = lexLookahead();

    while (c == ' ' || c == '\t') {

		lexSkipLookahead();

		c = lexLookahead();

	}

}



static char* lexGetWord() {

    int c;

    lexSkipWhite();

    lexClearToken();

    c = lexLookahead();

    while (c != EOF && !strchr("\t\n ;:=",c)) {

		lexAppendc(c);

		lexSkipLookahead();

		c = lexLookahead();

	}

    lexAppendc(0);

    return lexStr();

}



static void lexPushLookahead(char *s, int len) {

    int putptr;

    if (len == 0) len = strlen(s);

    putptr = (int)lexBuf.getPtr - len;

    /* this function assumes that length of word to push back

	/  is not greater than MAX_LEX_LOOKAHEAD.

	*/

    if (putptr < 0) putptr += MAX_LEX_LOOKAHEAD;

    lexBuf.getPtr = putptr;

    while (*s) {

		lexBuf.buf[putptr] = *s++;

		putptr = (putptr + 1) % MAX_LEX_LOOKAHEAD;

	}

    lexBuf.len += len;

}



static void lexPushLookaheadc(int c) 

{

    int putptr;

	

    /* can't putback EOF, because it never leaves lookahead buffer */

    if (c == EOF) 

		return;

    putptr = (int)lexBuf.getPtr - 1;



    if (putptr < 0) 

		putptr += MAX_LEX_LOOKAHEAD;

    lexBuf.getPtr = putptr;

    lexBuf.buf[putptr] = c;

    lexBuf.len += 1;

}



static char* lexLookaheadWord() 

{

    /* this function can lookahead word with max size of MAX_LEX_LOOKAHEAD_0

     /  and thing bigger than that will stop the lookahead and return 0;

     / leading white spaces are not recoverable.

     */

    int c;

    int len = 0;

    int curgetptr = 0;



    lexSkipWhite();

    lexClearToken();

    curgetptr = (int)lexBuf.getPtr;	// remember!

    

	while (len < (MAX_LEX_LOOKAHEAD_0)) {

		c = lexGetc();

		len++;

		if (c == EOF || strchr("\t\n ;:=", c)) {

			lexAppendc(0);

			/* restore lookahead buf. */

			lexBuf.len += len;

			lexBuf.getPtr = curgetptr;

			return lexStr();

	    }

        else

			lexAppendc(c);

	}

    lexBuf.len += len;	/* char that has been moved to lookahead buffer */

    lexBuf.getPtr = curgetptr;

    return 0;

}



#ifdef _SUPPORT_LINE_FOLDING

static void handleMoreRFC822LineBreak(int c) {

/* suport RFC 822 line break in cases like

*	ADR: foo;

*    morefoo;

*    more foo;

	*/

    if (c == ';') {

		int a;

		lexSkipLookahead();

		/* skip white spaces */

		a = lexLookahead();

		while (a == ' ' || a == '\t') {

			lexSkipLookahead();

			a = lexLookahead();

		}

		if (a == '\n') {

			lexSkipLookahead();

			a = lexLookahead();

			if (a == ' ' || a == '\t') {

			/* continuation, throw away all the \n and spaces read so

			* far

				*/

				lexSkipWhite();

				lexPushLookaheadc(';');

			}

			else {

				lexPushLookaheadc('\n');

				lexPushLookaheadc(';');

			}

		}

		else {

			lexPushLookaheadc(';');

		}

	}

}



static char* lexGet1Value() {

    int size = 0;

    int c;

    lexSkipWhite();

    c = lexLookahead();

    lexClearToken();

    while (c != EOF && c != ';') {

		if (c == '\n') {

			int a;

			lexSkipLookahead();

			a  = lexLookahead();

			if (a == ' ' || a == '\t') {

				lexAppendc(' ');

				lexSkipLookahead();

			}

			else {

				lexPushLookaheadc('\n');

				break;

			}

		}

		else {

			lexAppendc(c);

			lexSkipLookahead();

		}

		c = lexLookahead();

	}

    lexAppendc(0);

    handleMoreRFC822LineBreak(c);

    return c==EOF?0:lexStr();

}

#endif



static char* lexGetStrUntil(char *termset) {

    int size = 0;

    int c = lexLookahead();



    lexClearToken();

    while (c != EOF && !strchr(termset,c)) {

		lexAppendc(c);

		lexSkipLookahead();

		c = lexLookahead();

	}

    lexAppendc(0);

    return c==EOF?0:lexStr();

}

/***********************************************************************************************/

static int match_begin_name(int end) 

{

    char *n = lexLookaheadWord();

    int token = ID;

    if (n) {

		if (!stricmp(n,"vcard")) 

			token = end?END_VCARD:BEGIN_VCARD;

		else if (!stricmp(n,"vcalendar")) 

			token = end?END_VCAL:BEGIN_VCAL;

		else if (!stricmp(n,"vevent")) 

			token = end?END_VEVENT:BEGIN_VEVENT;

		else if (!stricmp(n,"vtodo")) 

			token = end?END_VTODO:BEGIN_VTODO;

		else if (!stricmp(n,"vnote")) 

			token = end?END_VNOTE:BEGIN_VNOTE;

		else if (!stricmp(n,"vmsg")) 

			token = end?END_VMESSAGE:BEGIN_VMESSAGE;

		else if (!stricmp(n,"venv")) 

			token = end?END_VMSGENV:BEGIN_VMSGENV;

		else if (!stricmp(n,"vbody")) 

			token = end?END_VBODY:BEGIN_VBODY;



		deleteStr(n);

		return token;

	}

    return 0;

}





#ifdef INCLUDEMFC

void initLex(const char *inputstring, unsigned long inputlen, CFile *inputfile)

#else

void initLex(const char *inputstring, unsigned long inputlen, FILE *inputfile)

#endif

{

    // initialize lex mode stack

    lexBuf.lexModeStack[lexBuf.lexModeStackTop=0] = L_NORMAL;



    // iniatialize lex buffer.

    lexBuf.inputString = (char*) inputstring;

    lexBuf.inputLen = inputlen;

    lexBuf.curPos = 0;

    lexBuf.inputFile = inputfile;



    lexBuf.len = 0;

    lexBuf.getPtr = 0;



    lexBuf.maxToken = MAXTOKEN;

    lexBuf.strs = (char*)malloc(MAXTOKEN);

    lexBuf.strsLen = 0;



}



static void finiLex() 

{

    free(lexBuf.strs);

}

DLLEXPORT(void) FinishParse()
{
	VObject* p = NULL;
	int  i = 0;
	p = popVObject();
	while (p) {
		cleanVObject(p);
		p = popVObject();
	}
	if (g_yys) {
		for (i = 0; i < g_yys_count; i++) {
			if ((YYSTYPE*)g_yys[i] != NULL) {
				free((YYSTYPE*)g_yys[i]);
			}
		}
		free(g_yys);
		g_yys = NULL;
		g_yys_count = 0;
	}
	yyss = NULL;
	yyssp = NULL;
	yystacksize = 0;
	yyvs = NULL;
}




/*/////////////////////////////////////////////////////////////////////////*/

/* This parses and converts the base64 format for binary encoding into

 * a decoded buffer (allocated with new).  See RFC 1521.

 */

static char * lexGetDataFromBase64()

{

    unsigned long bytesLen = 0, bytesMax = 0;

    int quadIx = 0, pad = 0;

    unsigned long trip = 0;

    unsigned char b;

    int c;

    unsigned char *bytes = NULL;

    unsigned char *oldBytes = NULL;

	

    DBG_(("db: lexGetDataFromBase64\n"));

    while (1) {

		c = lexGetc();

		if (c == '\n') {

			++mime_lineNum;

			if (lexLookahead() == '\n') {

				/* a '\n' character by itself means end of data */

				break;

			}

			else continue; /* ignore '\n' */

		}

		else {

			if ((c >= 'A') && (c <= 'Z'))

				b = (unsigned char)(c - 'A');

			else if ((c >= 'a') && (c <= 'z'))

				b = (unsigned char)(c - 'a') + 26;

			else if ((c >= '0') && (c <= '9'))

				b = (unsigned char)(c - '0') + 52;

			else if (c == '+')

				b = 62;

			else if (c == '/')

				b = 63;

			else if (c == '=') {

				b = 0;

				pad++;

			} else if ((c == ' ') || (c == '\t')) {

				continue;

			} else { /* error condition */

				if (bytes) free(bytes);

				else if (oldBytes) free(oldBytes);

				// error recovery: skip until 2 adjacent newlines.

				DBG_(("db: invalid character 0x%x '%c'\n", c,c));

				if (c != EOF)  {

					c = lexGetc();

					while (c != EOF) {

						if (c == '\n' && lexLookahead() == '\n') {

							++mime_lineNum;

							break;

						}

						c = lexGetc();

					}

				}

				return NULL;

			}

			trip = (trip << 6) | b;

			if (++quadIx == 4) {

				unsigned char outBytes[3];

				int numOut;

				int i;

				for (i = 0; i < 3; i++) {

					outBytes[2-i] = (unsigned char)(trip & 0xFF);

					trip >>= 8;

				}

				numOut = 3 - pad;

				if (bytesLen + numOut > bytesMax) {

					if (!bytes) {

						bytesMax = 1024;

						bytes = (unsigned char*)malloc((size_t)bytesMax);

					}

					else {

						bytesMax <<= 2;

						oldBytes = bytes;

						bytes = (unsigned char*)realloc(bytes,(size_t)bytesMax);

					}

					if (bytes == 0) {

						mime_error("out of memory while processing BASE64 data\n");

					}

				}

				if (bytes) {

					memcpy(bytes + bytesLen, outBytes, numOut);

					bytesLen += numOut;

				}

				trip = 0;

				quadIx = 0;

			}

		}

	} /* while */

    DBG_(("db: bytesLen = %d\n",  bytesLen));

    /* kludge: all this won't be necessary if we have tree form

	representation */

    if (bytes) {

		setValueWithSize(curProp,bytes,(unsigned int)bytesLen);

		free(bytes);

	}

    else if (oldBytes) {

		setValueWithSize(curProp,oldBytes,(unsigned int)bytesLen);

		free(oldBytes);

	}

    return 0;

}



static int match_begin_end_name(int end) 

{

    int token;

    

	lexSkipWhite();

    if (lexLookahead() != ':') 

		return ID;

    lexSkipLookahead();

    lexSkipWhite();

    token = match_begin_name(end);

    if (token == ID) 

	{

		lexPushLookaheadc(':');

		DBG_(("db: ID '%s'\n", yylval.str));

		return ID;

	}

    else if (token != 0) {

		lexSkipLookaheadWord();

		deleteStr(yylval.str);

		DBG_(("db: begin/end %d\n", token));

		return token;

	}

    return 0;

}



static char* lexGetQuotedPrintable()

{

    char cur;

    unsigned long len = 0;

	

    lexClearToken();

    do {

		cur = lexGetc();

		switch (cur) {

		case '=': {

			int c = 0;

			int next[2];

			int i;

			for (i = 0; i < 2; i++) {

				next[i] = lexGetc();

				if (next[i] >= '0' && next[i] <= '9')

					c = c * 16 + next[i] - '0';

				else if (next[i] >= 'A' && next[i] <= 'F')

					c = c * 16 + next[i] - 'A' + 10;

				else

					break;

			}

			if (i == 0) {

				/* single '=' follow by LINESEP is continuation sign? */

				if (next[0] == '\n') {

					++mime_lineNum;

				}

				else {

					lexPushLookaheadc('=');

					goto EndString;

				}

			}

			else if (i == 1) {

				lexPushLookaheadc(next[1]);

				lexPushLookaheadc(next[0]);

				lexAppendc('=');

			} else {

				lexAppendc(c);

			}

			break;

				  } /* '=' */

		case '\n': {

			lexPushLookaheadc('\n');

			goto EndString;

				   }

		case (char)EOF:

			break;

		default:

			lexAppendc(cur);

			break;

		} /* switch */

	} while (cur != (char)EOF);

	

EndString:

    lexAppendc(0);

    return lexStr();

} /* LexQuotedPrintable */





static int yylex() 

{

    int token = 0;

    int lexmode = LEXMODE();



    if (lexmode == L_VALUES) {

		int c = lexGetc();

		if (c == ';') {

			DBG_(("db: SEMICOLON\n"));

			lexPushLookaheadc(c);

			handleMoreRFC822LineBreak(c);

			lexSkipLookahead();

			return SEMICOLON;

	    }

		else if (strchr("\n",c)) {

			++mime_lineNum;

			/* consume all line separator(s) adjacent to each other */

			c = lexLookahead();

			while (strchr("\n",c)) {

				lexSkipLookahead();

				c = lexLookahead();

				++mime_lineNum;

			}

			DBG_(("db: LINESEP\n"));

			return LINESEP;

		}

		else {

			char *p = 0;

			lexPushLookaheadc(c);

			if (lexWithinMode(L_BASE64)) {

				/* get each char and convert to bin on the fly... */

				p = lexGetDataFromBase64();

				yylval.str = p;

				return STRING;

			}

			else if (lexWithinMode(L_QUOTED_PRINTABLE)) {

				p = lexGetQuotedPrintable();

			}

			else {

#ifdef _SUPPORT_LINE_FOLDING

				p = lexGet1Value();

#else

				p = lexGetStrUntil(";\n");

#endif

			}

			if (p) {

				DBG_(("db: STRING: '%s'\n", p));

				yylval.str = p;

				return STRING;

			}

			else return 0;

		}

	}

    else {

	/* normal mode */

		while (1) {

			int c = lexGetc();

			switch(c) {

				case ':': 

				{

					/* consume all line separator(s) adjacent to each other */

					/* ignoring linesep immediately after colon. */

					c = lexLookahead();

					while (strchr("\n",c)) {

						lexSkipLookahead();

						c = lexLookahead();

						++mime_lineNum;

					}

					DBG_(("db: COLON\n"));

					return COLON;

				}

				case ';':

					DBG_(("db: SEMICOLON\n"));

					return SEMICOLON;

				case '=':

					DBG_(("db: EQ\n"));

					return EQ;

				/* ignore whitespace in this mode */

				case '\t':

				case ' ': 

					continue;

				case '\n': 

					++mime_lineNum;

					continue;

				case EOF: 

					return 0;

					break;

				default: {

					lexPushLookaheadc(c);

					if (isalpha(c)) {

						char *t = lexGetWord();

						yylval.str = t;

						if (!stricmp(t, "begin")) {

							return match_begin_end_name(0);

						}

						else if (!stricmp(t,"end")) {

							return match_begin_end_name(1);

						}

						else {

							DBG_(("db: ID '%s'\n", t));

							return ID;

						}

					}

					else {

						/* unknow token */

						return 0;

					}

					break;

				}

			}

		}

	}

	return 0;

}





/***************************************************************************/

/***							Public Functions						****/

/***************************************************************************/



static VObject* Parse_MIMEHelper()

{

    ObjStackTop = -1;

    mime_numErrors = 0;

    mime_lineNum = 1;

    vObjList = 0;

    curObj = 0;

	

    if (yyparse() != 0) {
		finiLex();
		FinishParse();
		return 0;
    }


	

    finiLex();

    return vObjList;

}



/*/////////////////////////////////////////////////////////////////////////*/

DLLEXPORT(VObject*) Parse_MIME(const char *input, unsigned long len)

{

    initLex(input, len, 0);

    return Parse_MIMEHelper();

}





#if INCLUDEMFC



DLLEXPORT(VObject*) Parse_MIME_FromFile(CFile *file)

{

    unsigned long startPos;

    VObject *result;	

	

    initLex(0,-1,file);

    startPos = file->GetPosition();

    if (!(result = Parse_MIMEHelper()))

		file->Seek(startPos, CFile::begin);

    return result;

}



#else



DLLEXPORT(VObject*) Parse_MIME_FromFile(FILE *file)

{

    VObject *result;	

    long startPos;

	

    initLex(0,(unsigned long)-1,file);

    startPos = ftell(file);

    if (!(result = Parse_MIMEHelper())) {

		fseek(file,startPos,SEEK_SET);

	}

    return result;

}


DLLEXPORT(VObject*) Parse_MIME_FromFileName(char *fname)

{

    FILE *fp = fopen(fname,"r");

    if (fp) {

		VObject* o = Parse_MIME_FromFile(fp);

		fclose(fp);

		return o;

	}

    else {

		char msg[80];

		sprintf(msg, "can't open file '%s' for reading\n", fname);

		mime_error_(msg);

		return 0;

	}

}



#endif



/*/////////////////////////////////////////////////////////////////////////*/

static void YYDebug(const char *s)

{

	Parse_Debug(s);

}





static MimeErrorHandler mimeErrorHandler;



DLLEXPORT(void) registerMimeErrorHandler(MimeErrorHandler me)

{

    mimeErrorHandler = me;

}



static void mime_error(char *s)

{

    char msg[256];

	sprintf(msg,"%s at line %d\n", s, mime_lineNum);
    if (mimeErrorHandler) {

		mimeErrorHandler(msg);

	}
	_RPT0(_CRT_WARN, msg);

}



static void mime_error_(char *s)

{

    if (mimeErrorHandler) {

		mimeErrorHandler(s);

	}

}



////#line 1344 "y.tab.c"
/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack()
{
    int newsize, i;
    short *newss = NULL;
    YYSTYPE *newvs = NULL;

    if ((newsize = yystacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;
    i = yyssp - yyss;
    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
      (short *)malloc(newsize * sizeof *newss);
    if (newss == NULL)
        return -1;
    yyss = newss;
    yyssp = newss + i;
    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
      (YYSTYPE *)malloc(newsize * sizeof *newvs);
    if (newvs == NULL)
        return -1;

	g_yys_count += 2;
	if (g_yys_count == 2) {
		g_yys = (int*)malloc(sizeof(char*) * 2);
		g_yys[0] = (int)newss;
		g_yys[1] = (int)newvs;
	} else {
		g_yys = (int*)realloc(g_yys, i * sizeof(char*));
		g_yys[i-2] = (int)newss;
		g_yys[i-1] = (int)newvs;
	}

    yyvs = newvs;
    yyvsp = newvs + i;
    yystacksize = newsize;
    yysslim = yyss + newsize - 1;
    return 0;
}

#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab

#ifndef YYPARSE_PARAM
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG void
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG
#define YYPARSE_PARAM_DECL
#endif	/* ANSI-C/C++ */
#else	/* YYPARSE_PARAM */
#ifndef YYPARSE_PARAM_TYPE
#define YYPARSE_PARAM_TYPE void *
#endif
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
#endif	/* ANSI-C/C++ */
#endif	/* ! YYPARSE_PARAM */

int
yyparse (YYPARSE_PARAM_ARG)
    YYPARSE_PARAM_DECL
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register const char *yys;

    if ((yys = getenv("YYDEBUG")))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
	yydebug=1;
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    if (yyss == NULL && yygrowstack()) goto yyoverflow;
    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if ((yyn = yydefred[yystate])) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            myprintf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            myprintf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yysslim && yygrowstack())
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#if defined(lint) || defined(__GNUC__)
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#if defined(lint) || defined(__GNUC__)
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    myprintf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yysslim && yygrowstack())
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    myprintf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        /*if (yychar == 0)*/ goto yyabort;  //We don't do error recovery now, this can avoid many crash problem (By WeiJunping on 2004-3-17 16:14:25)
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            myprintf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        myprintf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 2:
////#line 216 "vcc.y"
{ 

		addList(&vObjList, yyvsp[0].vobj); 

		curObj = 0; 

	}
break;
case 4:
////#line 222 "vcc.y"
{	

		addList(&vObjList, yyvsp[0].vobj); 

		curObj = 0; 

	}
break;
case 9:
////#line 236 "vcc.y"
{

		lexPushMode(L_VMESSAGE);

		if (!pushVObject(VCMessageProp)) 

			YYERROR;

	}
break;
case 10:
////#line 243 "vcc.y"
{

		lexPopMode(0);

		yyval.vobj = popVObject();

	}
break;
case 14:
////#line 254 "vcc.y"
{

		lexPushMode(L_VMSGENV);

		if (!pushVObject(VCVEnvProp)) 

			YYERROR;

	}
break;
case 15:
////#line 261 "vcc.y"
{

		lexPopMode(0);

		yyval.vobj = popVObject();

	}
break;
case 18:
////#line 272 "vcc.y"
{

		lexPushMode(L_VBODY);

		if (!pushVObject(VCVBodyProp)) 

			YYERROR;

	}
break;
case 19:
////#line 279 "vcc.y"
{

		lexPopMode(0);

		yyval.vobj = popVObject();

	}
break;
case 20:
////#line 287 "vcc.y"
{

		lexPushMode(L_VNOTE);

		if (!pushVObject(VCNoteProp)) 

			YYERROR;

	}
break;
case 21:
////#line 294 "vcc.y"
{

		lexPopMode(0);

		yyval.vobj = popVObject();

	}
break;
case 22:
////#line 301 "vcc.y"
{/*////////////////////////////////////////////////////////////////////////////////
*/
		lexPushMode(L_VCARD);

		if (!pushVObject(VCCardProp)) 

			YYERROR;

	}
break;
case 23:
////#line 307 "vcc.y"
{

		lexPopMode(0);

		yyval.vobj = popVObject();

	}
break;
case 24:
////#line 312 "vcc.y"
{

		lexPushMode(L_VCARD);

		if (!pushVObject(VCCardProp)) 

			YYERROR;

	}
break;
case 25:
//#line 318 "vcc.y"
{

		lexPopMode(0);

		yyval.vobj = popVObject();

	}
break;
case 28:
//#line 329 "vcc.y"
{

		lexPushMode(L_VALUES);

	}
break;
case 29:
//#line 333 "vcc.y"
{

		if (lexWithinMode(L_BASE64) || lexWithinMode(L_QUOTED_PRINTABLE))

			lexPopMode(0);

		lexPopMode(0);

	}
break;
case 31:
//#line 342 "vcc.y"
{

		enterProps(yyvsp[0].str);

	}
break;
case 33:
//#line 347 "vcc.y"
{

		enterProps(yyvsp[0].str);

	}
break;
case 37:
//#line 360 "vcc.y"
{

		enterAttr(yyvsp[0].str,0);

	}
break;
case 38:
//#line 364 "vcc.y"
{

		enterAttr(yyvsp[-2].str,yyvsp[0].str);

	}
break;
case 40:
//#line 373 "vcc.y"
{ enterValues(yyvsp[-1].str); }
break;
case 42:
//#line 375 "vcc.y"
{ enterValues(yyvsp[0].str); }
break;
case 44:
//#line 380 "vcc.y"
{ yyval.str = 0; }
break;
case 45:
//#line 385 "vcc.y"
{ 

		if (!pushVObject(VCCalProp)) 

		YYERROR; 

	}
break;
case 46:
//#line 391 "vcc.y"
{ yyval.vobj = popVObject(); }
break;
case 47:
//#line 393 "vcc.y"
{ 

		if (!pushVObject(VCCalProp)) 

		YYERROR; 

	}
break;
case 48:
//#line 398 "vcc.y"
{ yyval.vobj = popVObject(); }
break;
case 54:
//#line 413 "vcc.y"
{

		lexPushMode(L_VEVENT);

		if (!pushVObject(VCEventProp)) 

			YYERROR;

	}
break;
case 55:
//#line 420 "vcc.y"
{

		lexPopMode(0);

		popVObject();

	}
break;
case 56:
//#line 425 "vcc.y"
{

		lexPushMode(L_VEVENT);

		if (!pushVObject(VCEventProp)) 

			YYERROR;

	}
break;
case 57:
//#line 431 "vcc.y"
{

		lexPopMode(0);

		popVObject();

	}
break;
case 58:
//#line 439 "vcc.y"
{

		lexPushMode(L_VTODO);

		if (!pushVObject(VCTodoProp)) 

			YYERROR;

	}
break;
case 59:
//#line 446 "vcc.y"
{

		lexPopMode(0);

		popVObject();

	}
break;
case 60:
//#line 451 "vcc.y"
{

		lexPushMode(L_VTODO);

		if (!pushVObject(VCTodoProp)) YYERROR;

	}
break;
case 61:
//#line 456 "vcc.y"
{

		lexPopMode(0);

		popVObject();

	}
break;
//#line 1774 "y.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            myprintf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                myprintf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        myprintf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yysslim && yygrowstack())
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
